This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-09T00:04:08.438Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/
  workflows/
    ci.yml
    test.yml
docs/
  about.md
  api.md
  configuration.md
  faq.md
  integration.md
modules/
  johnny-mnemonix.nix
tests/
  home-manager/
    example-config.nix
    spacer-config.nix
    state-tracking.nix
    structure-changes.nix
  cache.nix
  default.nix
.gitignore
.markdownlint.yaml
CHANGELOG.md
CONTRIBUTING.md
flake.lock
flake.nix
README.md
shell.nix

================================================================
Repository Files
================================================================

================
File: .github/workflows/ci.yml
================
name: CI

on:
  pull_request:
  workflow_dispatch:
  push:
    branches: [main, master]
    tags: ["v?[0-9]+.[0-9]+.[0-9]+*"]

# Prevent concurrent runs of the same workflow on the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Main CI workflow using Determinate CI
  DeterminateCI:
    uses: DeterminateSystems/ci/.github/workflows/workflow.yml@main
    permissions:
      id-token: "write"
      contents: "read"
    with:
      # Custom runner map for better performance
      runner-map: |
        {
          "aarch64-darwin": "macos-latest-xlarge",
          "aarch64-linux": "ubuntu-latest",
          "x86_64-darwin": "macos-latest-xlarge",
          "x86_64-linux": "ubuntu-latest"
        }
      # Make builds public on FlakeHub
      visibility: "public"

  # Check flake health
  check-flake:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: DeterminateSystems/nix-installer-action@main
      - uses: DeterminateSystems/magic-nix-cache-action@main
      - uses: DeterminateSystems/flake-checker-action@main
        with:
          fail-mode: true # Make CI fail if there are issues

  # Keep dependencies up to date
  # ... existing code ...

  update-flake:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          # Important: Fetch all history for updating flake references
          fetch-depth: 0

      - uses: DeterminateSystems/nix-installer-action@main
      - uses: DeterminateSystems/magic-nix-cache-action@main

      # Update flake.lock
      - name: Update flake.lock
        uses: DeterminateSystems/update-flake-lock@main
        with:
          # Required for creating PRs
          token: ${{ secrets.GITHUB_TOKEN }}
          # PR settings
          pr-title: "chore: update flake.lock"
          pr-labels: |
            dependencies
            automated
          # Commit settings
          commit-msg: "chore: update flake dependencies"
          branch: "update-flake-lock"
          # Optional: Add PR body
          pr-body: |
            Automated flake update via GitHub Actions

            This PR updates the flake.lock file to the latest versions of all inputs.

          # Optional: Configure git author
          git-author-name: "github-actions[bot]"
          git-author-email: "github-actions[bot]@users.noreply.github.com"

  # Additional checks for specific platforms
  platform-checks:
    needs: [DeterminateCI]
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        include:
          - os: ubuntu-latest
            system: x86_64-linux
          - os: macos-latest
            system: x86_64-darwin
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: DeterminateSystems/nix-installer-action@main
      - uses: DeterminateSystems/magic-nix-cache-action@main

      # Run system-specific checks
      - name: Check ${{ matrix.system }}
        run: |
          # Build and check the configuration for this system
          nix build .#${{ matrix.system }}

          # Run any additional system-specific tests
          nix flake check --system ${{ matrix.system }}

================
File: .github/workflows/test.yml
================
name: "Test"

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: cachix/install-nix-action@v25
      with:
        github_access_token: ${{ secrets.GITHUB_TOKEN }}
    - run: nix flake check

================
File: docs/about.md
================
# About Johnny-Mnemonix

## Philosophy

Johnny-Mnemonix combines two powerful ideas:
1. The organizational clarity of the Johnny.Decimal system
2. The reproducibility and declarative nature of Nix

The goal is to make document management both systematic and reproducible across systems, while maintaining the flexibility to adapt to individual needs.

## Core Concepts

### Johnny.Decimal System

The Johnny.Decimal system organizes information into a three-level hierarchy:

1. **Areas (10-19, 20-29, etc.)**
   - High level and distinct domains of your information
   - Like shelves in a bookcase
   - Each spans a range of numbers, the first number being the constant among the range (e.g., 10-19)

2. **Categories (11.xx, 12.xx, etc.)**
   - Specific groupings within areas
   - Like boxes (box-sets) on the shelves
   - Two-digit numbers within the area's range

3. **IDs (11.01, 11.02, etc.)**
   - Individual locations for items
   - Like books in the boxes
   - Format: Category.Index (e.g., 11.01)

### Nix Integration

Johnny-Mnemonix leverages Nix to make this system:

- **Declarative**: Your entire document structure is defined in code
- **Reproducible**: The same structure can be recreated on any system
- **Verifiable**: Built-in tests ensure your structure remains valid
- **Portable**: Works across Linux and Darwin systems
- **Integrated**: Works seamlessly with Home Manager

### Shell Integration

The project provides intuitive shell commands for navigation:

```bash
# Navigate to document root
jm

# Jump to specific locations
jm 11.01   # Goes to first item in category 11
jm finance  # Fuzzy finds finance-related directories

# List and search
jmls        # List document root
jmfind tax  # Find tax-related directories
```

## Why "Mnemonix"?

The name combines three elements:
1. **Johnny** - From Johnny.Decimal, the organizational system
2. **Mnemonic** - Greek for "memory aid" (the system helps remember locations)
3. **Nix** - The package manager and system configuration tool

It's also a nod to William Gibson's "Johnny Mnemonic" - a character who, like our system, helps manage and organize digital information.

## Design Principles

1. **Non-destructive**
   - Never deletes existing files
   - Safely merges with existing structures
   - Preserves user data

2. **Minimal Configuration**
   - Sensible defaults
   - Only configure what you need
   - Clear, focused options

3. **Shell-First**
   - Fast command-line navigation
   - Tab completion
   - Fuzzy finding

4. **XDG Compliant**
   - Follows XDG Base Directory specification
   - Respects system conventions
   - Clean home directory

## Getting Started

See our [Configuration Guide](./configuration.md) for detailed setup instructions, or check out the [examples](../examples) directory for quick-start configurations.

================
File: docs/api.md
================
# API Documentation

## State Management

Johnny-Mnemonix maintains state using a JSON-based tracking system:

```json
{
  "/path/to/directory": {
    "hash": "sha256-hash-of-contents",
    "timestamp": "2024-03-14T12:00:00Z"
  }
}
```

### State File Location
- Default: `${baseDir}/.johnny-mnemonix-state.json`
- Tracks directory content hashes and metadata
- Used for detecting renames and moves

### Directory Changes
Changes are tracked in `${baseDir}/.structure-changes`:
```
# Renamed: /old/path -> /new/path
# Moved: /source/path -> /target/path
# Deprecated: /old/path - reason for deprecation
```

================
File: docs/configuration.md
================
# Configuration Guide

## Flake Integration

First, add Johnny-Mnemonix to your flake inputs:

```nix
{
  inputs = {
    johnny-mnemonix = {
      url = "github:lessuselesss/johnny-mnemonix";
      inputs.nixpkgs.follows = "nixpkgs";  # Optional but recommended
    };
  };
}
```

## Home Manager Integration

For Darwin/MacOS systems, add it to your darwin configuration:

```nix
{
  home-manager.users.${user} = { config, ... }: {
    imports = [johnny-mnemonix.homeManagerModules.default];

    johnny-mnemonix = {
      enable = true;
      baseDir = "${config.home.homeDirectory}/Documents";
      shell = {
        enable = true;
        prefix = "jm";
        aliases = true;
        functions = true;
      };
      areas = {
        "10-19" = {
          name = "Personal";
          categories = {
            "11" = {
              name = "Finance";
              items = {
                "11.01" = "Budget";
                "11.02" = "Investments";
              };
            };
          };
        };
      };
    };
  };
}
```

For NixOS systems, add it to your NixOS configuration:

```nix
{
  home-manager.users.${user} = { config, ... }: {
    imports = [johnny-mnemonix.homeManagerModules.default];
    # Same configuration as above
  };
}
```

## Configuration Options

### Required Options

| Option | Type | Description |
|--------|------|-------------|
| `enable` | boolean | Must be set to `true` to activate the module |
| `baseDir` | string | Base directory for document structure (e.g., `${config.home.homeDirectory}/Documents`) |

### Shell Integration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `shell.enable` | boolean | `false` | Enable shell integration |
| `shell.prefix` | string | `"jm"` | Command prefix for shell functions |
| `shell.aliases` | boolean | `false` | Enable shell aliases |
| `shell.functions` | boolean | `false` | Enable shell functions |

### Area Configuration

Areas must follow the Johnny Decimal format:

```nix
areas = {
  "10-19" = {
    name = "Personal";
    categories = {
      "11" = {
        name = "Finance";
        items = {
          "11.01" = "Budget";
          "11.02" = "Investments";
        };
      };
    };
  };
};
```

### Git Repository Examples

```nix
items = {
  # Basic repository - clones everything
  "11.01" = {
    url = "https://github.com/user/repo";
  };

  # Repository with specific branch
  "11.02" = {
    url = "https://github.com/user/repo";
    ref = "develop";  # Checkout this branch after cloning
  };

  # Repository with sparse checkout (partial clone)
  "11.03" = {
    url = "https://github.com/user/large-repo";
    ref = "main";
    # Only these paths will be checked out, saving disk space
    # and reducing initial clone time
    sparse = [
      # Directory patterns
      "docs/*.md"              # Only markdown files directly in docs/
      "docs/**/*.md"           # Markdown files in docs/ and all subdirectories
      "src/components/"        # Everything in the components directory

      # File patterns
      "README.md"              # Single file in root
      "package.json"           # Another single file

      # Multiple file types
      "assets/*.{png,jpg}"     # PNG and JPG files in assets/

      # Complex patterns
      "src/*/index.js"         # index.js in any immediate subdirectory of src/
      "tests/**/*_test.js"     # All test files in tests/ and subdirectories

      # Negative patterns (exclude)
      "!node_modules/**"       # Exclude all node_modules content
      "!**/*.log"             # Exclude all log files everywhere
    ];
  };

  # Private repository using SSH
  "11.04" = {
    url = "git@github.com:user/private-repo.git";
    ref = "main";
  };
};
```

#### Understanding Sparse Checkout Patterns

The `sparse` option uses Git's sparse-checkout pattern syntax:

| Pattern | Example | Description |
|---------|---------|-------------|
| `*` | `docs/*` | Matches any string except `/` |
| `**` | `docs/**` | Matches any string including `/` |
| `{x,y}` | `*.{jpg,png}` | Matches any of the alternatives |
| `!pattern` | `!node_modules` | Excludes matching paths |

Common use cases:
```nix
sparse = [
  # Documentation only
  "docs/**"                # All documentation files
  "*.md"                   # All markdown files in root

  # Source code subset
  "src/specific-module/**" # Just one module
  "src/**/*.ts"           # All TypeScript files

  # Configuration files
  "config/*.json"         # JSON configs in config/
  ".*rc"                  # All RC files in root

  # Mixed content
  "assets/images/*.svg"   # SVG files only
  "scripts/deploy/*"      # Deployment scripts only

  # Exclude patterns
  "!**/*.test.js"        # No test files
  "!**/dist/**"          # No build artifacts
];
```

**Important Notes:**
- Patterns are evaluated in order
- Later patterns can override earlier ones
- More specific patterns should come after general ones
- Exclude patterns (`!`) should typically come last
- Empty list means full checkout (no sparse-checkout)
```

## State Management

Johnny-Mnemonix follows the XDG Base Directory Specification:

```nix
{
  johnny-mnemonix = {
    enable = true;
    baseDir = "${config.home.homeDirectory}/Documents";
    # State files are automatically managed in XDG directories:
    # - State: $XDG_STATE_HOME/johnny-mnemonix/state.json (default: ~/.local/state/johnny-mnemonix/)
    # - Cache: $XDG_CACHE_HOME/johnny-mnemonix/ (default: ~/.cache/johnny-mnemonix/)
    # - Config: $XDG_CONFIG_HOME/johnny-mnemonix/ (default: ~/.config/johnny-mnemonix/)
  };
}
```

### State Files Location

| File | XDG Path | Default Location | Purpose |
|------|----------|-----------------|----------|
| `state.json` | `$XDG_STATE_HOME/johnny-mnemonix/` | `~/.local/state/johnny-mnemonix/state.json` | Directory content hashes and metadata |
| `structure-changes.log` | `$XDG_STATE_HOME/johnny-mnemonix/` | `~/.local/state/johnny-mnemonix/structure-changes.log` | Directory structure change history |
| `cache.json` | `$XDG_CACHE_HOME/johnny-mnemonix/` | `~/.cache/johnny-mnemonix/cache.json` | Shell completion cache |
| `config.json` | `$XDG_CONFIG_HOME/johnny-mnemonix/` | `~/.config/johnny-mnemonix/config.json` | Runtime configuration |

### Custom Locations

You can override default locations:

```nix
{
  johnny-mnemonix = {
    enable = true;
    baseDir = "${config.home.homeDirectory}/Documents";
    xdg = {
      # Optional: override default XDG paths
      stateHome = "/path/to/state";
      cacheHome = "/path/to/cache";
      configHome = "/path/to/config";
    };
  };
}
```

## Verification

After applying changes, verify your setup:

1. Check directory structure:
```bash
ls ~/Documents/10-19\ Personal/11\ Finance/
```

2. Verify state files:
```bash
# Check state
cat ~/.local/state/johnny-mnemonix/state.json

# Check change history
cat ~/.local/state/johnny-mnemonix/structure-changes.log

# Check cache
cat ~/.cache/johnny-mnemonix/cache.json
```

## Basic Configuration

```nix
{
  johnny-mnemonix = {
    enable = true;
    baseDir = "${config.home.homeDirectory}/Documents";
    spacer = " ";  # Character between ID and name (optional, defaults to space)

    # Git settings
    git = {
      autoFetch = true;        # Automatically fetch updates
      fetchInterval = 1800;    # Fetch interval in seconds (30 minutes)
      sparseByDefault = true;  # Enable sparse checkout by default
    };

    # Backup settings
    backup = {
      enable = true;           # Enable automatic backups
      interval = "daily";      # Options: "hourly", "daily", "weekly"
      location = "/backup/documents";  # Backup destination
    };

    # Directory structure
    areas = {
      "10-19" = {
        name = "Personal";
        categories = {
          "11" = {
            name = "Finance";
            items = {
              "11.01" = "Budget";
              "11.02" = {
                name = "Investment Tracker";
                url = "git@github.com:user/investments.git";  # Git repository
                ref = "main";    # Optional: branch/tag/commit
                sparse = [];     # Optional: sparse checkout patterns
              };
              "11.03" = {
                name = "Shared Documents";
                target = "/path/to/shared/docs";  # Symlink target
              };
            };
          };
        };
      };
    };
  };
}
```

## Options Reference

### Core Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enable` | boolean | `false` | Enable johnny-mnemonix |
| `baseDir` | string | `"${config.home.homeDirectory}/Documents"` | Base directory for document structure |
| `spacer` | string | `" "` | Character(s) between ID and name |

### Git Integration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `git.autoFetch` | boolean | `true` | Automatically fetch updates |
| `git.fetchInterval` | integer | `3600` | Seconds between fetches |
| `git.sparseByDefault` | boolean | `false` | Enable sparse checkout by default |

### Backup Settings

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `backup.enable` | boolean | `false` | Enable automatic backups |
| `backup.interval` | enum | `"daily"` | Backup frequency ("hourly", "daily", "weekly") |
| `backup.location` | null or path | `null` | Backup destination path |

### Directory Structure

Areas, categories, and items follow the Johnny Decimal system:
- Areas: `XX-YY` format (e.g., "10-19")
- Categories: `XX` format (e.g., "11")
- Items: `XX.YY` format (e.g., "11.01")

#### Item Types

1. **Simple Directory**
```nix
"11.01" = "Budget";
```

2. **Git Repository**
```nix
"11.02" = {
  name = "Project";
  url = "git@github.com:user/repo.git";
  ref = "main";     # Optional
  sparse = [];      # Optional
};
```

3. **Symlink**
```nix
"11.03" = {
  name = "Shared";
  target = "/path/to/target";
};
```

================
File: docs/faq.md
================
# Frequently Asked Questions

## Directory Management

### Q: What happens when I rename a category?
A: Johnny-Mnemonix uses content hashing to detect renames:
1. Generates hash of directory contents
2. Compares with known directory hashes
3. If a match is found, moves content to new location
4. Updates state tracking file
5. Logs change in `.structure-changes`

### Q: Are my files ever deleted?
A: No. Johnny-Mnemonix follows a non-destructive approach:
- Existing files are never deleted
- Directories are moved or merged, not removed
- All changes are logged for audit purposes

### Q: How does conflict resolution work?
A: When conflicts occur (same name, different content):
1. Both directories are preserved
2. Content hashes are compared
3. Different hashes indicate unique content
4. Changes are logged for manual resolution

## Configuration

### Q: Can I change my directory structure after initial setup?
A: Yes! The system is designed for evolution:
- Rename categories safely
- Move items between categories
- Add new areas and categories
- All while preserving existing content

### Q: What's the recommended way to handle temporary files?
A: We recommend using a dedicated temporary area:
```nix
areas = {
  "90-99" = {
    name = "Temporary";
    categories = {
      "91" = {
        name = "Drafts";
        items = {
          "91.01" = "Current";
          "91.02" = "Archive";
        };
      };
    };
  };
};
```

### Q: Can I use custom separators instead of spaces?
A: Yes, configure the spacer option:
```nix
johnny-mnemonix = {
  enable = true;
  spacer = "-";  # Results in: 10-19-Personal
};
```

## Shell Integration

### Q: How do I customize the shell command prefix?
A: Set the prefix in your configuration:
```nix
johnny-mnemonix.shell = {
  enable = true;
  prefix = "jd";  # Changes commands to: jd, jdls, jdfind
};
```

### Q: Why aren't shell completions working?
A: Ensure you have:
1. Enabled shell integration:
   ```nix
   johnny-mnemonix.shell.enable = true;
   ```
2. Enabled your shell's completion system:
   ```nix
   programs.zsh.enableCompletion = true;
   # or
   programs.bash.enableCompletion = true;
   ```
3. Rebuilt your configuration:
   ```bash
   home-manager switch
   ```

## Git Integration

### Q: How do I exclude certain directories from Git?
A: Use category-specific `.gitignore` files:
```gitignore
# In 10-19 Personal/.gitignore
11 Finance/**/*.pdf
12 Health/**/*.private
```

### Q: Can I use different Git repositories for different areas?
A: Yes, configure Git repositories per item:
```nix
items = {
  "11.01" = {
    name = "Budget";
    url = "git@github.com:user/budget.git";
  };
};
```

### Q: How does Git integration work with sparse checkouts?
A: Johnny-Mnemonix supports Git's sparse-checkout feature:
```nix
items = {
  "11.01" = {
    name = "Repository";
    url = "https://github.com/user/repo.git";
    sparse = [
      "docs/**/*.md"    # Only markdown files in docs/
      "src/core/**"     # Only core module files
      "!tests/**"       # Exclude test files
    ];
  };
};
```

## Performance

### Q: Will this slow down my shell startup?
A: No, Johnny-Mnemonix is designed for minimal impact:
- Shell functions are lazy-loaded
- Completions are cached
- State tracking is incremental

### Q: How does it handle large directories?
A: Several optimizations are in place:
- Content hashing is done incrementally
- Sparse checkouts for Git repositories
- State caching for faster lookups

## Troubleshooting

### Q: Why did my directory structure not update after rebuilding?
A: Check these common issues:
1. Ensure configuration was applied:
   ```bash
   home-manager generations
   ```
2. Look for errors in the state file:
   ```bash
   cat ~/.johnny-mnemonix-state.json
   ```
3. Check the structure changes log:
   ```bash
   cat .structure-changes
   ```

### Q: How do I reset the state tracking?
A: You can safely remove the state files:
```bash
rm .johnny-mnemonix-state.json
rm .structure-changes
home-manager switch  # Regenerates state
```

## Best Practices

### Q: What's the recommended way to organize documents?
A: Follow these guidelines:
1. Use clear, descriptive names
2. Keep areas focused and distinct
3. Limit categories to related items
4. Use consistent naming conventions

### Q: Should I version control my entire document structure?
A: Consider a hybrid approach:
1. Version control configuration
2. Selectively git-ignore sensitive data
3. Use sparse checkouts for large repositories
4. Maintain separate backups for critical data

### Q: How should I handle shared directories?
A: Options include:
1. Symlinks to shared locations
2. Git submodules for versioned content
3. Dedicated sync areas for collaborative work

================
File: docs/integration.md
================
# Integration Guide

This guide covers how to integrate Johnny-Mnemonix with other tools and systems in your development environment.

## Home Manager Integration

### Basic Integration

Add Johnny-Mnemonix to your flake inputs:

```nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    johnny-mnemonix.url = "github:lessuselesss/johnny-mnemonix";
  };
}
```

Import the module in your Home Manager configuration:

```nix
{
  imports = [
    johnny-mnemonix.homeManagerModules.default
  ];
}
```

### Multiple User Configurations

For systems with multiple users:

```nix
{
  homeManagerConfigurations = {
    user1 = home-manager.lib.homeManagerConfiguration {
      modules = [
        johnny-mnemonix.homeManagerModules.default
        {
          johnny-mnemonix = {
            enable = true;
            baseDir = "~/Documents";
          };
        }
      ];
    };
    user2 = home-manager.lib.homeManagerConfiguration {
      modules = [
        johnny-mnemonix.homeManagerModules.default
        {
          johnny-mnemonix = {
            enable = true;
            baseDir = "~/workspace";  # Different base directory
          };
        }
      ];
    };
  };
}
```

## Shell Integration

Johnny-Mnemonix provides intuitive shell commands:

```bash
# Navigate to document root
jm

# Jump to specific locations
jm 11.01   # Goes to first item in category 11
jm finance  # Fuzzy finds finance-related directories

# List and search
jmls        # List document root
jmfind tax  # Find tax-related directories
```

### Zsh Integration

Johnny-Mnemonix automatically integrates with Zsh when enabled:

```nix
{
  johnny-mnemonix.shell = {
    enable = true;
    prefix = "jm";  # Default prefix
  };

  programs.zsh.enable = true;  # Required for Zsh integration
}
```

### Bash Integration

Similar configuration for Bash users:

```nix
{
  johnny-mnemonix.shell = {
    enable = true;
    prefix = "jm";
  };

  programs.bash.enable = true;  # Required for Bash integration
}
```

### Custom Shell Functions

You can extend the shell integration with custom functions:

```nix
{
  programs.zsh.initExtra = ''
    # Custom function to create new document
    ${config.johnny-mnemonix.shell.prefix}-new() {
      local id="$1"
      local name="$2"
      if [[ -z "$id" || -z "$name" ]]; then
        echo "Usage: jm-new <id> <name>"
        return 1
      fi
      mkdir -p "$(${config.johnny-mnemonix.shell.prefix}find "$id")/$name"
    }
  '';
}
```

## Git Integration

### Repository Structure

Johnny-Mnemonix works well with Git-managed documents. Recommended structure:

```
Documents/
├── .git/
├── 10-19 Personal/
│   └── .gitignore  # Category-specific ignores
├── 20-29 Work/
│   └── .gitignore
└── .gitignore      # Global ignores
```

### Example .gitignore

```gitignore
# Global ignores
.DS_Store
*.log
*.tmp

# Category-specific patterns
10-19 Personal/11 Finance/**/*.pdf
20-29 Work/21 Projects/**/*.secret
```

## XDG Integration

Johnny-Mnemonix follows XDG Base Directory specifications:

```nix
{
  johnny-mnemonix = {
    enable = true;
    # Configuration stored in $XDG_CONFIG_HOME/johnny-mnemonix
    # Cache stored in $XDG_CACHE_HOME/johnny-mnemonix
    # Data stored in $XDG_DATA_HOME/johnny-mnemonix
  };
}
```

## Development Tools Integration

### Pre-commit Hooks

Johnny-Mnemonix includes pre-commit hooks for maintaining code quality:

```yaml
# .pre-commit-config.yaml
repos:
  - repo: local
    hooks:
      - id: johnny-mnemonix-check
        name: Check Johnny-Mnemonix structure
        entry: nix run .#check
        language: system
        pass_filenames: false
```

### Direnv Integration

For project-specific environment variables:

```nix
# .envrc
use flake
export JOHNNY_MNEMONIX_BASE="$PWD"
```

## Testing Integration

Johnny-Mnemonix includes a test suite that can be integrated into your CI/CD pipeline:

```nix
{
  checks = forAllSystems (system: {
    vm-test = import ./tests {
      pkgs = pkgsForSystem system;
    };
  });
}
```

### Running Tests Locally

```bash
# Run all tests
nix flake check

# Run specific test
nix eval .#checks.x86_64-linux.vm-test
```

## IDE Integration

### VSCode Settings

Recommended settings for VSCode:

```json
{
  "files.associations": {
    "*.jd": "markdown"
  },
  "search.exclude": {
    "**/node_modules": true,
    "**/bower_components": true,
    "**/*.code-search": true,
    "**/.[0-9][0-9].*": true
  }
}
```

### Emacs Configuration

For Emacs users:

```elisp
(use-package johnny-mnemonix
  :mode ("\\.jd\\'" . markdown-mode)
  :hook (markdown-mode . johnny-mnemonix-mode))
```

## Future Integrations

We're working on integrations with:
- Typst document processor
- NixOS container support
- Remote filesystem synchronization
- Additional shell environments

For more information on upcoming integrations, see our [roadmap](./roadmap.md).

================
File: modules/johnny-mnemonix.nix
================
{
  config,
  lib,
  pkgs,
  ...
}:
with lib; let
  cfg = config.johnny-mnemonix;

  # XDG paths
  xdgStateHome = cfg.xdg.stateHome or "${config.home.homeDirectory}/.local/state";
  xdgCacheHome = cfg.xdg.cacheHome or "${config.home.homeDirectory}/.cache";
  xdgConfigHome = cfg.xdg.configHome or "${config.home.homeDirectory}/.config";
  xdgDataHome = "${config.home.homeDirectory}/.local/share";

  # Directory locations
  stateDir = "${xdgStateHome}/johnny-mnemonix";
  cacheDir = "${xdgCacheHome}/johnny-mnemonix";
  configDir = "${xdgConfigHome}/johnny-mnemonix";

  stateFile = "${stateDir}/state.json";
  changesFile = "${stateDir}/structure-changes.log";
  cacheFile = "${cacheDir}/cache.json";

  # Cache operations
  mkCacheOps = ''
    read_cache() {
      if [ -f "${cacheFile}" ]; then
        cat "${cacheFile}"
      else
        echo "{}"
      fi
    }

    write_cache() {
      echo "$1" > "${cacheFile}"
    }

    cache_directory_hash() {
      local path="$1"
      local hash="$2"
      local cache=$(read_cache)
      echo "$cache" | ${pkgs.jq}/bin/jq --arg path "$path" --arg hash "$hash" '. + {($path): $hash}' > "${cacheFile}"
    }

    get_cached_hash() {
      local path="$1"
      local cache=$(read_cache)
      echo "$cache" | ${pkgs.jq}/bin/jq -r --arg path "$path" '.[$path] // empty'
    }
  '';

  # Type definitions
  itemOptionsType = types.submodule {
    options = {
      name = mkOption {
        type = types.str;
        description = "Directory name for the item";
      };
      url = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "Optional Git repository URL";
      };
      ref = mkOption {
        type = types.str;
        default = "main";
        description = "Git reference (branch, tag, or commit)";
      };
      sparse = mkOption {
        type = types.listOf types.str;
        default = [];
        description = "Sparse checkout patterns (empty for full checkout)";
      };
      target = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "Optional path to create symlink to";
      };
    };
  };

  itemType = types.either types.str itemOptionsType;

  # Git wrapper
  gitWithSsh = pkgs.writeShellScriptBin "git-with-ssh" ''
    # Ensure SSH knows about GitHub's host key
    if [ ! -f ~/.ssh/known_hosts ] || ! grep -q "^github.com" ~/.ssh/known_hosts; then
      mkdir -p ~/.ssh
      chmod 700 ~/.ssh
      ${pkgs.openssh}/bin/ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null
    fi

    # Set Git to use SSH
    export GIT_SSH="${pkgs.openssh}/bin/ssh"
    export PATH="${lib.makeBinPath [pkgs.git pkgs.openssh]}:$PATH"

    # Run Git command
    exec git "$@"
  '';

  # Generate a stable hash for directory contents
  mkContentHash = path: ''
    if [ -d "${path}" ]; then
      find "${path}" -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1
    else
      echo "0000000000000000000000000000000000000000000000000000000000000000"
    fi
  '';

  # Helper to read/write state (updated to use XDG paths)
  mkStateOps = ''
    mkdir -p "${stateDir}" "${cacheDir}" "${configDir}"

    read_state() {
      if [ -f "${stateFile}" ]; then
        cat "${stateFile}"
      else
        echo "{}"
      fi
    }

    write_state() {
      echo "$1" > "${stateFile}"
    }

    update_state() {
      local path="$1"
      local hash="$2"
      local state=$(read_state)
      echo "$state" | ${pkgs.jq}/bin/jq --arg path "$path" --arg hash "$hash" '. + {($path): $hash}'
    }

    log_change() {
      echo "$1" >> "${changesFile}"
    }
  '';

  # Enhanced directory handling
  mkAreaDirs = areas: let
    mkCategoryDirs = areaId: areaConfig: categoryId: categoryConfig: let
      # First, define the item handling function
      mkItemDir = itemId: itemConfig: let
        newPath = "${cfg.baseDir}/${areaId}${cfg.spacer}${areaConfig.name}/${categoryId}${cfg.spacer}${categoryConfig.name}/${itemId}";
        itemDef =
          if isString itemConfig
          then {
            name = itemConfig;
            url = null;
          }
          else itemConfig;
      in ''
        mkdir -p "${newPath}"

        ${
          if itemDef.url != null
          then ''
            if [ ! -d "${newPath}/.git" ]; then
              ${gitWithSsh}/bin/git-with-ssh clone ${
              if itemDef ? sparse && itemDef.sparse != []
              then "--sparse"
              else ""
            } \
                --branch ${itemDef.ref or "main"} \
                ${itemDef.url} "${newPath}"

              ${optionalString (itemDef ? sparse && itemDef.sparse != []) ''
              cd "${newPath}"
              ${gitWithSsh}/bin/git-with-ssh sparse-checkout set ${concatStringsSep " " itemDef.sparse}
            ''}
            fi
          ''
          else if itemDef ? target && itemDef.target != null
          then ''
            if [ ! -e "${newPath}" ]; then
              ln -s "${itemDef.target}" "${newPath}"
            fi
          ''
          else ""
        }
      '';
    in
      concatMapStrings (itemId: mkItemDir itemId categoryConfig.items.${itemId})
      (attrNames categoryConfig.items);

    mkAreaDir = areaId: areaConfig:
      concatMapStrings (
        categoryId:
          mkCategoryDirs areaId areaConfig categoryId areaConfig.categories.${categoryId}
      ) (attrNames areaConfig.categories);
  in ''
    # Ensure base directory exists
    mkdir -p "${cfg.baseDir}"

    # Create area directories
    ${concatMapStrings (areaId: mkAreaDir areaId areas.${areaId}) (attrNames areas)}
  '';

  # Shell functions
  mkShellFunctions = prefix: ''
    # Basic navigation
    ${prefix}() {
      local base="${cfg.baseDir}"
      if [ -z "$1" ]; then
        cd "$base"
      else
        local target=$(find "$base" -type d -name "*$1*" | head -n 1)
        if [ -n "$target" ]; then
          cd "$target"
        else
          echo "No matching directory found"
          return 1
        fi
      fi
    }

    # Up navigation
    ${prefix}-up() {
      cd ..
    }

    # Listing commands
    ${prefix}ls() {
      ls "${cfg.baseDir}"
    }

    ${prefix}l() {
      ls -l "${cfg.baseDir}"
    }

    ${prefix}ll() {
      ls -la "$@"
    }

    ${prefix}la() {
      ls -la "$@"
    }

    # Find command
    ${prefix}find() {
      if [ -z "$1" ]; then
        echo "Usage: ${prefix}find <pattern>"
        return 1
      fi
      find "${cfg.baseDir}" -type d -name "*$1*"
    }

    # Shell completion
    if [[ -n "$ZSH_VERSION" ]]; then
      compdef _jm_completion ${prefix}
      compdef _jm_completion ${prefix}ls
      compdef _jm_completion ${prefix}find

      function _jm_completion() {
        local curcontext="$curcontext" state line
        typeset -A opt_args

        case "$words[1]" in
          ${prefix})
            _arguments '1:directory:_jm_dirs'
            ;;
          ${prefix}ls)
            _arguments '1:directory:_jm_dirs'
            ;;
          ${prefix}find)
            _message 'pattern to search for'
            ;;
        esac
      }

      function _jm_dirs() {
        local base="${cfg.baseDir}"
        _files -W "$base" -/
      }

    elif [[ -n "$BASH_VERSION" ]]; then
      complete -F _jm_completion ${prefix}
      complete -F _jm_completion ${prefix}ls
      complete -F _jm_completion ${prefix}find

      function _jm_completion() {
        local cur prev
        COMPREPLY=()
        cur="$2"
        prev="$3"
        base="${cfg.baseDir}"

        case "$1" in
          ${prefix})
            COMPREPLY=($(compgen -d "$base/$cur" | sed "s|$base/||"))
            ;;
          ${prefix}ls)
            COMPREPLY=($(compgen -d "$base/$cur" | sed "s|$base/||"))
            ;;
          ${prefix}find)
            # No completion for find pattern
            ;;
        esac
      }
    fi
  '';
in {
  options.johnny-mnemonix = {
    enable = mkEnableOption "johnny-mnemonix";

    baseDir = mkOption {
      type = types.str;
      description = "Base directory for johnny-mnemonix";
    };

    spacer = mkOption {
      type = types.str;
      default = " ";
      example = "-";
      description = "Character(s) to use between ID and name";
    };

    shell = {
      enable = mkEnableOption "shell integration";
      prefix = mkOption {
        type = types.str;
        default = "jm";
        description = "Command prefix for shell integration";
      };
      aliases = mkEnableOption "shell aliases";
      functions = mkEnableOption "shell functions";
    };

    areas = mkOption {
      type = types.attrsOf (types.submodule {
        options = {
          name = mkOption {
            type = types.str;
            description = "Name of the area";
          };
          categories = mkOption {
            type = types.attrsOf (types.submodule {
              options = {
                name = mkOption {
                  type = types.str;
                  description = "Name of the category";
                };
                items = mkOption {
                  type = types.attrsOf itemType;
                  description = "Items in the category";
                };
              };
            });
            description = "Categories within the area";
          };
        };
      });
      default = {};
      description = "Areas configuration";
    };

    xdg = {
      stateHome = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "Override default XDG_STATE_HOME location";
      };

      cacheHome = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "Override default XDG_CACHE_HOME location";
      };

      configHome = mkOption {
        type = types.nullOr types.str;
        default = null;
        description = "Override default XDG_CONFIG_HOME location";
      };
    };

    git = {
      autoFetch = mkOption {
        type = types.bool;
        default = true;
        description = "Automatically fetch git repositories";
      };
      fetchInterval = mkOption {
        type = types.int;
        default = 3600;
        description = "Interval between git fetches (in seconds)";
      };
      sparseByDefault = mkOption {
        type = types.bool;
        default = false;
        description = "Enable sparse checkout by default for new repositories";
      };
    };

    backup = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = "Enable automatic backups";
      };
      interval = mkOption {
        type = types.enum ["hourly" "daily" "weekly"];
        default = "daily";
        description = "Backup frequency";
      };
      location = mkOption {
        type = types.nullOr types.path;
        default = null;
        description = "Backup destination path";
      };
      time = mkOption {
        type = types.str;
        default = "00:00:00";
        description = "Time of day to run backup (HH:MM:SS)";
      };
    };

    programs = mkOption {
      type = types.attrsOf types.anything;
      default = {};
      description = "Program configurations";
    };

    home = mkOption {
      type = types.attrsOf types.anything;
      default = {};
      description = "Home-manager configurations";
    };
  };

  config = mkIf cfg.enable {
    assertions = [
      {
        assertion = !cfg.backup.enable || cfg.backup.location != null;
        message = "backup.location must be set when backup is enabled";
      }
    ];

    home = {
      packages = with pkgs; [
        git
        openssh
        gitWithSsh
        jq
      ];

      activation.createJohnnyMnemonixDirs = lib.hm.dag.entryAfter ["writeBoundary"] ''
        ${mkCacheOps}
        ${mkAreaDirs cfg.areas}
      '';
    };

    # Combine all programs configuration into a single attribute set
    programs = {
      zsh = mkIf cfg.shell.enable {
        enable = true;
        enableCompletion = true;
        initExtra = mkShellFunctions cfg.shell.prefix;
      };

      bash = mkIf cfg.shell.enable {
        enable = true;
        enableCompletion = true;
        initExtra =
          mkShellFunctions cfg.shell.prefix
          + ''
            export JOHNNY_MNEMONIX_CONFIG="${configDir}"
            export JOHNNY_MNEMONIX_CACHE="${cacheDir}"
            export JOHNNY_MNEMONIX_DATA="${xdgDataHome}/johnny-mnemonix"
            export JOHNNY_MNEMONIX_STATE="${stateDir}"
          '';
      };
    };

    systemd.user.timers.johnny-mnemonix-backup = mkIf cfg.backup.enable {
      Timer = {
        Unit = "johnny-mnemonix-backup.service";
        OnCalendar = let
          calendar = {
            hourly = "*-*-* *:00:00";
            daily = "*-*-* ${cfg.backup.time}";
            weekly = "Mon *-*-* ${cfg.backup.time}";
          };
        in
          calendar.${cfg.backup.interval};
        Persistent = true;
      };
    };
  };
}

================
File: tests/home-manager/example-config.nix
================
_: {
  # Basic home-manager configuration
  home = {
    username = "test";
    homeDirectory = "/home/test";
    stateVersion = "24.11";
  };

  # Johnny-Mnemonix configuration
  johnny-mnemonix = {
    enable = true;
    baseDir = "/home/test/johnny-mnemonix";
    spacer = "_";
    areas = {
      # System - About the system.
      "00-09" = {
        name = "_System_";
        categories = {
          "00" = {
            name = "[Meta]";
            items = {
              "00.01" = {
                name = "Placeholder";
              };
              "00.02" = {
                name = "Placeholder";
              };
            };
          };
          "01" = {
            name = "[Home]";
            items = {
              "01.00" = {
                name = "Dotfiles";
                target = "/home/test/.dotfiles";
              };
              "01.01" = {
                name = "Applications";
                target = "/home/test/Applications";
              };
              "01.02" = {
                name = "Desktop";
                target = "/home/test/Desktop";
              };
              "01.03" = {
                name = "Documents";
                target = "/home/test/Documents";
              };
              "01.04" = {
                name = "Downloads";
                target = "/home/test/Downloads";
              };
              "01.05" = {
                name = "Movies";
                target = "/home/test/Movies";
              };
              "01.06" = {
                name = "Music";
                target = "/home/test/Music";
              };
              "01.07" = {
                name = "Pictures";
                target = "/home/test/Pictures";
              };
              "01.08" = {
                name = "Public";
                target = "/home/test/Public";
              };
              "01.09" = {
                name = "Templates";
                target = "/home/test/Templates";
              };
            };
          };
          "02" = {
            name = "[Cloud]";
            items = {
              "02.01" = {
                name = "Dropbox";
              };
              "02.02" = {
                name = "Google Drive";
              };
            };
          };
        };
      };

      # Projects - Short-term efforts in your work or life that you're working on now.
      "10-19" = {
        name = "_Projects_";
        categories = {
          "11" = {
            name = "[Maintaining]";
            items = {
              "11.01" = {
                name = "Johnny-Mnemonix";
                url = "https://github.com/lessuselesss/johnny-mnemonix";
                ref = "main";
                sparse = [
                  "/examples/*"
                ];
              };
              "11.02" = {
                name = "Forks";
              };
            };
          };
          "12" = {
            name = "[Pending]";
            items = {
              "12.01" = {
                name = "Waiting";
              };
              "12.02" = {
                name = "In Review";
              };
            };
          };
        };
      };

      # Areas - Long-term responsibilities you want to manage over time.
      "20-29" = {
        name = "_Areas_";
        categories = {
          "21" = {
            name = "[Personal]";
            items = {
              "21.01" = {
                name = "Health";
              };
              "21.02" = {
                name = "Finance";
              };
              "21.03" = {
                name = "Family";
              };
            };
          };
          "22" = {
            name = "[Professional]";
            items = {
              "22.01" = {
                name = "Career";
              };
              "22.02" = {
                name = "Skills";
              };
            };
          };
        };
      };

      # Topics or interests that may be useful in the future.
      "30-39" = {
        name = "_Resources_";
        categories = {
          "31" = {
            name = "[References]";
            items = {
              "31.01" = {
                name = "Technical";
              };
              "31.02" = {
                name = "Academic";
              };
            };
          };
          "32" = {
            name = "[Collections]";
            items = {
              "32.01" = {
                name = "Templates";
              };
              "32.02" = {
                name = "Checklists";
              };
            };
          };
        };
      };

      # Archive - Completed projects, references, and other resources that you no longer need to manage actively.
      "90-99" = {
        name = "_Archive_";
        categories = {
          "90" = {
            name = "[Completed]";
            items = {
              "90.01" = {
                name = "Projects";
              };
              "90.02" = {
                name = "References";
              };
            };
          };
          "91" = {
            name = "[Deprecated]";
            items = {
              "91.01" = {
                name = "Old Documents";
              };
              "91.02" = {
                name = "Legacy Files";
              };
            };
          };
        };
      };
    };
  };
}

================
File: tests/home-manager/spacer-config.nix
================
{lib, ...}: {
  name = "spacer-config";

  nodes.machine = {pkgs, ...}: {
    imports = [../../modules/johnny-mnemonix.nix];
    environment.systemPackages = [pkgs.coreutils];
    home-manager.users.testuser = {
      johnny-mnemonix = {
        enable = true;
        baseDir = "/tmp/test-jm";
        spacer = "-";
      };
    };
  };

  testScript = let
    basePath = lib.escapeShellArg "/tmp/test-jm";
    testPaths = [
      "10-19-Personal"
      "10-19-Personal/11-Finance"
      "10-19-Personal/11-Finance/11.01-Budget"
    ];
  in ''
    machine.wait_for_unit("multi-user.target")

    ${lib.concatMapStrings (path: ''
        machine.succeed("test -d ${basePath}/${lib.escapeShellArg path}")
      '')
      testPaths}

    machine.fail("test -d ${basePath}/10-19 Personal")
  '';
}

================
File: tests/home-manager/state-tracking.nix
================
{
  pkgs,
  lib,
  ...
}: let
  # Helper to create test files with specific content
  mkTestFile = name: content: ''
    echo "${content}" > "${name}"
  '';

  # Initial configuration
  initialConfig = {
    johnny-mnemonix = {
      enable = true;
      baseDir = "/tmp/test-jm";
      areas = {
        "10-19" = {
          name = "Personal";
          categories = {
            "11" = {
              name = "Finance";
              items = {
                "11.01" = {
                  name = "Budget";
                };
              };
            };
          };
        };
      };
    };
  };

  # Updated configuration with renamed category
  renamedConfig = {
    johnny-mnemonix = {
      enable = true;
      baseDir = "/tmp/test-jm";
      areas = {
        "10-19" = {
          name = "Personal";
          categories = {
            "11" = {
              name = "Money"; # Renamed from "Finance"
              items = {
                "11.01" = {
                  name = "Budget";
                };
              };
            };
          };
        };
      };
    };
  };

  # Test assertions
  assertStateFile = query: ''
    state_content=$(cat /tmp/test-jm/.johnny-mnemonix-state.json)
    if ! echo "$state_content" | ${pkgs.jq}/bin/jq -e "${query}" > /dev/null; then
      echo "State file assertion failed!"
      echo "Expected query: ${query}"
      echo "Got content: $state_content"
      exit 1
    fi
  '';

  assertDirExists = dir: ''
    if [ ! -d "${dir}" ]; then
      echo "Directory ${dir} does not exist!"
      exit 1
    fi
  '';

  assertDirNotExists = dir: ''
    if [ -d "${dir}" ]; then
      echo "Directory ${dir} should not exist!"
      exit 1
    fi
  '';

  assertContentPreserved = dir: content: ''
    if [ "$(cat ${dir}/test.txt)" != "${content}" ]; then
      echo "Content in ${dir}/test.txt was not preserved!"
      echo "Expected: ${content}"
      echo "Got: $(cat ${dir}/test.txt)"
      exit 1
    fi
  '';
in {
  name = "state-tracking";

  nodes.machine = {pkgs, ...}: {
    imports = [../../modules/johnny-mnemonix.nix];
    home-manager.users.testuser = lib.mkMerge [
      initialConfig
      # We'll apply renamedConfig later in the test
    ];
  };

  testScript = ''
    machine.wait_for_unit("multi-user.target")

    # Create initial structure and add some content
    machine.succeed('''
      # Create test content
      mkdir -p "/tmp/test-jm/10-19 Personal/11 Finance/11.01 Budget"
      ${mkTestFile "/tmp/test-jm/10-19 Personal/11 Finance/11.01 Budget/test.txt" "test content"}

      # Initial build
      home-manager switch
    ''')

    # Verify initial state
    machine.succeed('''
      ${assertDirExists "/tmp/test-jm/10-19 Personal/11 Finance"}
      ${assertStateFile ".[].path | select(contains(\\\"Finance\\\")) | length > 0"}
    ''')

    # Apply configuration with renamed category
    machine.succeed('''
      # Update home-manager configuration
      ${lib.generators.toJSON {} renamedConfig} > /tmp/renamed-config.json
      home-manager switch -I johnny-mnemonix-config=/tmp/renamed-config.json

      # Verify directory structure after rename
      ${assertDirExists "/tmp/test-jm/10-19 Personal/11 Money"}
      ${assertDirNotExists "/tmp/test-jm/10-19 Personal/11 Finance"}
      ${assertContentPreserved "/tmp/test-jm/10-19 Personal/11 Money/11.01 Budget" "test content"}

      # Verify state file updates
      ${assertStateFile ".[].path | select(contains(\\\"Money\\\")) | length > 0"}
    ''')

    # Test content hash matching
    machine.succeed('''
      # Create directory with identical content
      mkdir -p "/tmp/test-jm/10-19 Personal/11 Test"
      cp -r "/tmp/test-jm/10-19 Personal/11 Money/11.01 Budget"/* "/tmp/test-jm/10-19 Personal/11 Test/"

      # Verify hash matching works
      ${assertStateFile ".[].path | select(contains(\\\"Test\\\")) | length > 0"}
      ${assertStateFile "to_entries | map(select(.value == .[\\\"Money\\\"].hash)) | length == 2"}
    ''')

    # Test conflict handling
    machine.succeed('''
      # Create conflicting content
      mkdir -p "/tmp/test-jm/10-19 Personal/11 Conflict"
      ${mkTestFile "/tmp/test-jm/10-19 Personal/11 Conflict/test.txt" "different content"}

      # Verify different content produces different hash
      ${assertStateFile "to_entries | map(.value) | unique | length == 3"}
    ''')
  '';
}

================
File: tests/home-manager/structure-changes.nix
================
{lib, ...}: let
  initialConfig = {
    johnny-mnemonix = {
      enable = true;
      baseDir = "/tmp/test-jm";
      areas = {
        "10-19" = {
          name = "Personal";
          categories = {
            "11" = {
              name = "Finance";
              items = {
                "11.01" = "Budget";
              };
            };
          };
        };
      };
    };
  };

  updatedConfig = {
    johnny-mnemonix = {
      enable = true;
      baseDir = "/tmp/test-jm";
      areas = {
        "10-19" = {
          name = "Personal";
          categories = {
            "11" = {
              name = "Money";
              items = {
                "11.02" = {
                  name = "Budget";
                  target = "/tmp/test-jm/10-19 Personal/11 Finance/11.01 Budget";
                };
              };
            };
          };
        };
      };
    };
  };

  # Test helpers
  assertFileContains = file: content: ''
    if ! grep -q "${content}" "${file}"; then
      echo "Expected to find '${content}' in ${file}"
      exit 1
    fi
  '';

  assertDirExists = dir: ''
    if [ ! -d "${dir}" ]; then
      echo "Expected directory ${dir} to exist"
      exit 1
    fi
  '';
in {
  name = "structure-changes";

  nodes.machine = {pkgs, ...}: {
    imports = [../../modules/johnny-mnemonix.nix];
    home-manager.users.testuser = lib.mkMerge [
      initialConfig
      # Apply initial config, then updated config
      (lib.mkAfter updatedConfig)
    ];
  };

  testScript = ''
    machine.wait_for_unit("multi-user.target")

    # Check structure changes log
    ${assertFileContains "/tmp/test-jm/.structure-changes" "Renamed: Finance -> Money"}
    ${assertFileContains "/tmp/test-jm/.structure-changes" "Moved: 11.01 Budget -> 11.02 Budget"}

    # Verify directory structure
    ${assertDirExists "/tmp/test-jm/10-19 Personal"}
    ${assertDirExists "/tmp/test-jm/10-19 Personal/11 Money"}
    ${assertDirExists "/tmp/test-jm/10-19 Personal/11 Money/11.02 Budget"}

    # Check symlink
    machine.succeed("test -L '/tmp/test-jm/10-19 Personal/11 Money/11.02 Budget'")
  '';
}

================
File: tests/cache.nix
================
{
  pkgs,
  lib,
  ...
}: let
  # Mock home-manager configuration
  mockConfig = {
    home.homeDirectory = "/home/test";
    xdg.cacheHome = "/home/test/.cache";

    johnny-mnemonix = {
      enable = true;
      baseDir = "/home/test/Documents";
      areas = {
        "10-19" = {
          name = "Test";
          categories = {
            "11" = {
              name = "Cache Test";
              items = {
                "11.01" = "Test Dir";
              };
            };
          };
        };
      };
    };
  };

  # Test that cache operations work
  testCache = pkgs.writeShellScript "test-cache" ''
    set -e

    # Use mock config values with escaped paths
    export HOME=${lib.escapeShellArg mockConfig.home.homeDirectory}
    export XDG_CACHE_HOME=${lib.escapeShellArg mockConfig.xdg.cacheHome}

    # Setup test environment
    mkdir -p $HOME/.cache/johnny-mnemonix
    mkdir -p $HOME/Documents

    # Test cache initialization
    cache=$(read_cache)
    if [ "$cache" != "{}" ]; then
      echo "❌ Cache initialization failed"
      exit 1
    fi

    # Test cache writing
    test_path="/home/test/Documents/test"
    test_hash="abc123"
    cache_directory_hash "$test_path" "$test_hash"

    # Test cache reading
    cached_hash=$(get_cached_hash "$test_path")
    if [ "$cached_hash" != "$test_hash" ]; then
      echo "❌ Cache read/write failed"
      exit 1
    fi

    echo "✅ Cache tests passed"
  '';
in {
  name = "johnny-mnemonix-cache-tests";

  test = ''
    # Run cache tests
    ${testCache}
  '';
}

================
File: tests/default.nix
================
{
  pkgs,
  lib,
  home-manager,
  ...
}: let
  # Helper to create a minimal home-manager configuration
  mkHomeConfig = {config ? {}, ...}:
    home-manager.lib.homeManagerConfiguration {
      inherit pkgs;
      modules = [
        ../modules/johnny-mnemonix.nix
        {
          home = {
            username = "testuser";
            homeDirectory = "/home/testuser";
            stateVersion = "23.11";
          };
          johnny-mnemonix = config;
        }
      ];
    };

  # Test cases
  tests = {
    # Test basic configuration
    basic = mkHomeConfig {
      config = {
        enable = true;
        baseDir = "/tmp/test";
        spacer = " ";
        areas = {
          "10-19" = {
            name = "Test";
            categories = {
              "11" = {
                name = "Category";
                items = {
                  "11.01" = {name = "Item";};
                };
              };
            };
          };
        };
      };
    };

    # Test with Git repository
    withGit = mkHomeConfig {
      config = {
        enable = true;
        baseDir = "/tmp/test";
        spacer = " ";
        areas = {
          "10-19" = {
            name = "Test";
            categories = {
              "11" = {
                name = "Category";
                items = {
                  "11.01" = {
                    name = "Item";
                    url = "https://github.com/example/repo.git";
                    ref = "main";
                  };
                };
              };
            };
          };
        };
      };
    };

    # Test with symlinks
    withSymlinks = mkHomeConfig {
      config = {
        enable = true;
        baseDir = "/tmp/test";
        spacer = " ";
        areas = {
          "10-19" = {
            name = "Test";
            categories = {
              "11" = {
                name = "Category";
                items = {
                  "11.01" = {
                    name = "Item";
                    target = "/some/target/path";
                  };
                };
              };
            };
          };
        };
      };
    };

    # Test XDG paths
    withXdg = mkHomeConfig {
      config = {
        enable = true;
        baseDir = "/tmp/test";
        spacer = " ";
        xdg = {
          stateHome = "/home/testuser/.local/state";
          cacheHome = "/home/testuser/.cache";
          configHome = "/home/testuser/.config";
        };
        areas = {
          "10-19" = {
            name = "Test";
            categories = {
              "11" = {
                name = "Category";
                items = {
                  "11.01" = {name = "Item";};
                };
              };
            };
          };
        };
      };
    };
  };
in {
  # Run the tests
  test =
    pkgs.runCommand "test-johnny-mnemonix" {
      nativeBuildInputs = [pkgs.git];
    } ''
      echo "Running johnny-mnemonix tests..."

      ${lib.concatStringsSep "\n" (lib.mapAttrsToList (name: config: ''
          echo "Testing ${name}..."
          if ! ${config.activationPackage}/activate; then
            echo "Test ${name} failed!"
            exit 1
          fi
        '')
        tests)}

      echo "All tests passed!"
      touch $out
    '';
}

================
File: .gitignore
================
.pre-commit-config.yaml
.DS_Store
/result

================
File: .markdownlint.yaml
================
default: true
MD013: false  # Line length
MD033: false  # Inline HTML
MD041: false  # First line h1

================
File: CHANGELOG.md
================
# Changelog

All notable changes to Johnny-Mnemonix will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Git repository integration with sparse checkout support
- XDG Base Directory compliance
- Shell integration with improved navigation commands
- Backup functionality with configurable intervals
- State tracking for directory structure changes

### Changed
- Shell command prefix from `jd` to `jm`
- Directory structure handling to be more robust

### Deprecated
- None

### Removed
- None

### Fixed
- None

### Security
- None

## [0.1.0] - YYYY-MM-DD
- Initial release

[Unreleased]: https://github.com/lessuselesss/johnny-mnemonix/compare/v0.1.0...HEAD
[0.1.0]: https://github.com/lessuselesss/johnny-mnemonix/releases/tag/v0.1.0

================
File: CONTRIBUTING.md
================
# Contributing to Johnny-Mnemonix

Thank you for your interest in contributing to Johnny-Mnemonix! This document provides guidelines and information for contributors.

## Code of Conduct

Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.

## Getting Started

1. **Fork the Repository**
   ```bash
   git clone https://github.com/lessuselesss/johnny-mnemonix.git
   cd johnny-mnemonix
   ```

2. **Set Up Development Environment**
   ```bash
   # Enter development shell
   nix develop
   ```

3. **Make Your Changes**
   - Write clear, concise commit messages
   - Follow the existing code style
   - Add tests for new features
   - Update documentation as needed

## Development Guidelines

### Code Style

- Follow the Nixpkgs coding style
- Use meaningful variable names
- Add comments for complex logic
- Keep functions focused and small

### Commit Messages

Format:
```
type(scope): description

[optional body]
[optional footer]
```

Types:
- feat: New feature
- fix: Bug fix
- docs: Documentation changes
- style: Formatting changes
- refactor: Code restructuring
- test: Adding tests
- chore: Maintenance tasks

### Testing

1. **Run Tests**
   ```bash
   nix flake check
   ```

2. **Test Configuration**
   ```bash
   home-manager build -I johnny-mnemonix=.
   ```

### Documentation

- Update README.md for user-facing changes
- Add/update documentation in docs/
- Include examples for new features
- Document breaking changes

## Pull Request Process

1. **Create Feature Branch**
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. **Make Changes**
   - Follow development guidelines
   - Keep changes focused
   - Test thoroughly

3. **Submit Pull Request**
   - Describe changes clearly
   - Reference related issues
   - Update documentation
   - Add tests if needed

4. **Review Process**
   - Address review comments
   - Keep discussion focused
   - Be patient and respectful

## Release Process

1. **Version Bumping**
   - Update version in flake.nix
   - Update CHANGELOG.md
   - Create release notes

2. **Testing**
   - Verify all tests pass
   - Check documentation
   - Test installation process

3. **Release**
   - Tag release in git
   - Update documentation
   - Announce changes

## Getting Help

- Open an issue for questions
- Join community discussions
- Read existing documentation

Thank you for contributing to Johnny-Mnemonix!

================
File: flake.lock
================
{
  "nodes": {
    "home-manager": {
      "inputs": {
        "nixpkgs": [
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1733484277,
        "narHash": "sha256-i5ay20XsvpW91N4URET/nOc0VQWOAd4c4vbqYtcH8Rc=",
        "owner": "nix-community",
        "repo": "home-manager",
        "rev": "d00c6f6d0ad16d598bf7e2956f52c1d9d5de3c3a",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "home-manager",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1733392399,
        "narHash": "sha256-kEsTJTUQfQFIJOcLYFt/RvNxIK653ZkTBIs4DG+cBns=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "d0797a04b81caeae77bcff10a9dde78bc17f5661",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "home-manager": "home-manager",
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}

================
File: flake.nix
================
{
  description = "A Nix home-manager module for managing directory structures";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = {
    self,
    nixpkgs,
    home-manager,
  }: let
    systems = ["x86_64-linux" "aarch64-linux" "aarch64-darwin" "x86_64-darwin"];
    forAllSystems = f:
      nixpkgs.lib.genAttrs systems (system:
        f {
          pkgs = nixpkgs.legacyPackages.${system};
          inherit system;
        });
  in {
    homeManagerModules.default = import ./modules/johnny-mnemonix.nix;

    checks = forAllSystems ({
      pkgs,
      system,
    }: {
      moduleEval = let
        username = "testuser";
        homeDirectory = "/home/testuser";

        # Create a test home-manager configuration
        hmConfig = home-manager.lib.homeManagerConfiguration {
          inherit pkgs;
          modules = [
            self.homeManagerModules.default
            {
              home = {
                inherit username homeDirectory;
                stateVersion = "23.11";
              };
              johnny-mnemonix = {
                enable = true;
                baseDir = "/tmp/test";
                spacer = " ";
                areas = {};
              };
            }
          ];
        };
      in
        pkgs.runCommand "test-johnny-mnemonix-eval" {} ''
          echo "Checking module evaluation..."
          ${hmConfig.activationPackage}/activate || exit 1
          touch $out
        '';
    });

    devShells = forAllSystems ({pkgs, ...}: {
      default = pkgs.mkShell {
        buildInputs = with pkgs; [
          git
          nixpkgs-fmt
        ];
      };
    });
  };
}

================
File: README.md
================
[![CI](https://github.com/lessuselesss/johnny-mnemonix/actions/workflows/ci.yml/badge.svg)](https://github.com/lessuselesss/johnny-mnemonix/actions/workflows/ci.yml)

# Johnny-Mnemonix

> Declarative document management using the Johnny Decimal system, powered by Nix Flakes

Johnny-Mnemonix is a Home Manager module that brings the power of declarative configuration to your document management, implementing the [Johnny Decimal](https://johnnydecimal.com/) system in a Nix-native way. It provides a structured, reproducible approach to organizing your `$HOME/Documents` directory (aka your `$HOMEOFFICE`).

**Note**: Johnny-Mnemonix is designed exclusively for Nix Flakes and does not support legacy Nix usage.

## Features

- 🏗️ **Declarative Structure**: Define your entire document hierarchy in Nix, ensuring consistency across systems
- 📁 **Johnny Decimal Implementation**: First-class support for the [Johnny Decimal](https://johnnydecimal.com/) organizational system
- 🔄 **XDG Compliance**:
  - Follows XDG Base Directory specifications for configuration and cache data
  - Maintains state tracking under `${XDG_STATE_HOME}/johnny-mnemonix`
  - Handles directory structure changes gracefully
- 🔄 **Version Control Ready**:
  - Designed to work well with Git for document versioning
  - Native support for Git repositories in the document structure
  - Symlink support for shared resources
- 🏠 **Home Manager Native**: Integrates naturally with your existing Home Manager configuration

## Requirements

- Nix with flakes enabled:

```nix
{
  nix = {
    extraOptions = ''
      experimental-features = nix-command flakes
    '';
  };
}
```

## Directory Structure

When enabled, Johnny-Mnemonix creates the following structure:


```
$HOMEOFFICE/ #($HOME/Documents/)
├── 10-19 Area/
│   ├── ...
│   ├── 15.XX Category/
│   │   ├── ...
│   │   ├── 15.51 ...
│   │   └── 15.52 ID/
│   └── ...
├── x0-x9 Area/
│   ├── ...
│   ├── x0.XX Category/
│   │   ├── ...
│   │   ├── x0.01 ID/
│   │   ├── x0.XX ...
│   │   └── x0.99 ID/
│   └── ...
└── ...
```
<img src="https://johnnydecimal.com/img/v6/11.01A-Diagram_1552_NYC--dtop-1_resize-dark-cx-1000x609.png" style="max-width: 800px; width: 100%" alt="Johnny.Decimal system diagram">

Each component follows the Johnny Decimal system, `analogizing a Book Case`

`shelf`

- **Areas**: Groupings of categories (10-19, 20-29, etc.)

`box`

- **Categories**: Groupings of items (11, 12, etc.)

`book`

- **IDs**: Counter starting at 01 (11.01, 11.02, etc.)

## Development

### Prerequisites

- Nix with flakes enabled
- Git

### Development Environment

To get started:

```bash
# Clone the repository
git clone https://github.com/lessuselesss/johnny-mnemonix
cd johnny-mnemonix

# Enter development environment
nix develop
```

The development environment provides:
- Pre-commit hooks for code quality
- Nix formatting with Alejandra
- Static analysis with Statix
- Dead code detection with Deadnix
- Nix LSP (nil) for better IDE integration

### Code Quality Tools

Pre-commit hooks are automatically installed and run on each commit. They check for:
- Proper formatting (Alejandra)
- Static analysis (Statix)
- Dead code (Deadnix)
- Basic file hygiene (trailing whitespace, file endings, etc.)
- Nix flake correctness

To run checks manually:

```bash
pre-commit run --all-files
```

### Continuous Integration

Our CI pipeline (powered by [Determinate Systems](https://determinate.systems/)) runs:
1. Pre-commit checks
2. Multi-platform builds (NixOS, nix-darwin)
3. Flake checks
4. Dependency updates

## Installation & Usage

### 1. Add to Flake Inputs
In your system's `flake.nix`, add Johnny-Mnemonix to your inputs:

```nix
{
  inputs = {
    nixpkgs.url = "github:nixpkgs/nixpkgs/nixos-unstable";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    johnny-mnemonix.url = "github:lessuselesss/johnny-mnemonix";
  };

  outputs = { self, nixpkgs, home-manager, johnny-mnemonix }: {
    homeManagerConfigurations.${user} = home-manager.lib.homeManagerConfiguration {
      # Your existing config...
      modules = [
        johnny-mnemonix.homeManagerModules.default
        ./home.nix
      ];
    };
  };
}
```

### 2. Configure Your Document Structure
In your `home.nix` (or other Home Manager configuration file), define your document structure:

```nix
{
  johnny-mnemonix = {
    enable = true;
    baseDir = "${config.home.homeDirectory}/Documents";
    spacer = " "; # Character between ID and name

    # Git settings
    git = {
      autoFetch = true;
      fetchInterval = 1800;
      sparseByDefault = true;
    };

    # Backup settings
    backup = {
      enable = true;
      interval = "daily";
      location = "/backup/documents";
    };

    # XDG compliance
    xdg = {
      stateHome = null;  # Optional override
      cacheHome = null;  # Optional override
      configHome = null; # Optional override
    };

    areas = {
      "10-19" = {
        name = "Personal";
        categories = {
          "11" = {
            name = "Finance";
            items = {
              "11.01" = "Budget";
              "11.02" = {
                name = "Investment Tracker";
                url = "git@github.com:user/investments.git";
                ref = "main";  # Optional: specify branch/ref
                sparse = [];   # Optional: sparse checkout patterns
              };
              "11.03" = {
                name = "Shared Documents";
                target = "/path/to/shared/docs";  # Symlink target
              };
            };
          };
          "12" = {
            name = "Health";
            items = {
              "12.01" = "Medical Records";
              "12.02" = "Fitness Plans";
            };
          };
        };
      };
      "20-29" = {
        name = "Work";
        categories = {
          "21" = {
            name = "Projects";
            items = {
              "21.01" = {
                name = "Current Project";
                url = "https://github.com/company/project.git";
              };
              "21.02" = "Project Archive";
            };
          };
        };
      };
    };
  };
}
```

### 3. Apply Configuration
Run Home Manager to create your directory structure:

```bash
home-manager switch
```

This will create a directory structure like:

```
Documents/
├── 10-19 Personal/
│   ├── 11 Finance/
│   │   ├── 11.01 Budget/
│   │   └── 11.02 Investments/
│   └── 12 Health/
│       ├── 12.01 Medical Records/
│       └── 12.02 Fitness Plans/
└── 20-29 Work/
    └── 21 Projects/
        ├── 21.01 Current Project/
        └── 21.02 Project Archive/
```

### 4. Navigate Your Structure
After installation, you can use the provided shell alias to navigate to your document root:

```bash
# Navigate to document root
jm

# Or navigate to specific locations
jm 11.01   # Goes to first item in category 11
jm finance  # Fuzzy finds finance-related directories
```

### Important Notes

- The directory structure is created non-destructively (won't overwrite existing directories)
- All directory names must follow the Johnny Decimal format:
  - Areas: XX-YY format (e.g., "10-19")
  - Categories: XX format (e.g., "11")
  - Items: XX.YY format (e.g., "11.01")
- The `jd` alias is available in both bash and zsh
- You can modify the structure by updating your configuration and running `home-manager switch` again

## Roadmap

Future enhancements planned for Johnny-Mnemonix:

### Near-term
- [ ] Shell navigation commands (`jm`, `jmls`, etc.)
- [ ] Smart search functionality
- [ ] Integration with [Typix](https://github.com/loqusion/typix) for deterministic document compilation
- [ ] Integration with [ragenix](https://github.com/yaxitech/ragenix) for encrypted documents
- [ ] Git repository management within the document structure
- [ ] Automatic backup configuration

### Mid-term
- [ ] Document templates system
- [ ] Integration with popular document editors
- [ ] Document metadata management
- [ ] Advanced search capabilities with filtering and tagging

### Long-term
- [ ] AI-powered document organization suggestions
- [ ] Extended encryption options and key management
- [ ] Document integrity verification
- [ ] Version control policy management

## Contributing

Contributions are welcome! Please see [CONTRIBUTING.md](./CONTRIBUTING.md) for guidelines.

Before submitting a PR:
1. Enter the development environment: `nix develop`
2. Ensure all pre-commit hooks pass: `pre-commit run --all-files`
3. Verify CI checks pass locally: `nix flake check`

## License

MIT License - See [LICENSE](./LICENSE) for details.

================
File: shell.nix
================
{pkgs ? import <nixpkgs> {}}: let
  # Create a wrapper script to ensure cached-nix-shell is available
  ensureCachedShell = pkgs.writeShellScriptBin "ensure-cached-shell" ''
    if ! command -v cached-nix-shell &> /dev/null; then
      echo "Installing cached-nix-shell..."
      nix-env -iA nixpkgs.cached-nix-shell
    fi
  '';
in
  pkgs.mkShell {
    packages = with pkgs; [
      # Development environment setup helper
      ensureCachedShell

      # Pre-commit and its dependencies
      pre-commit
      alejandra # Single formatter
      statix
      deadnix

      # Other development tools
      nil # Nix LSP
    ];

    shellHook = ''
      # Ensure cached-nix-shell is installed
      ensure-cached-shell

      # Install pre-commit hooks
      pre-commit install

      echo "Development environment ready!"
      echo "Pre-commit hooks installed:"
      pre-commit list-hooks

      # Use cached-nix-shell for subsequent loads
      if [ -z "$CACHED_NIX_SHELL" ]; then
        export CACHED_NIX_SHELL=1
        exec cached-nix-shell "$SHELL_NIX" "$@"
      fi
    '';
  }
