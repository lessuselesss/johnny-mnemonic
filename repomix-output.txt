This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-06T05:52:53.640Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
docs/
  about.md
  api.md
  configuration.md
  examples.md
  faq.md
  integration.md
  migration.md
  performance.md
  plugins.md
  security.md
  testing.md
  troubleshooting.md
examples/
  flake.nix
lib/
  default.nix
  schema.nix
  utils.nix
modules/
  core/
    activation.nix
    default.nix
    validation.nix
  core.nix
  default.nix
tests/
  performance/
    structure.nix
CHANGELOG.md
CONTRIBUTING.md
default.nix
flake.lock
flake.nix
README.md

================================================================
Repository Files
================================================================

================
File: docs/about.md
================
# About Johnny-Mnemonix

## What is Johnny-Mnemonix?

Johnny-Mnemonix is a declarative document management system built on the principles of the Johnny Decimal system, implemented as a Nix Home Manager module. It combines the power of Nix's declarative configuration with the organizational clarity of Johnny Decimal to create a reproducible, maintainable document management solution.

## Why Johnny-Mnemonix?

### The Problem

Document management is often:
- Inconsistent across systems
- Hard to maintain over time
- Difficult to reproduce
- Prone to entropy and disorder

### The Solution

Johnny-Mnemonix addresses these issues by:
- Providing a declarative configuration
- Enforcing consistent structure
- Making organization reproducible
- Integrating with existing tools

## Core Principles

1. **Declarative Configuration**
   - Define structure in code
   - Version control friendly
   - Reproducible across systems

2. **Johnny Decimal System**
   - Clear numerical structure
   - Intuitive organization
   - Easy navigation

3. **Nix Integration**
   - Home Manager module
   - Pure functional approach
   - Reproducible builds

## System Design

### Architecture

```
Johnny-Mnemonix
├── Configuration (Nix)
│   ├── Structure Definition
│   ├── Validation Rules
│   └── Shell Integration
├── File System
│   ├── Directory Creation
│   ├── Permission Management
│   └── Structure Maintenance
└── User Interface
    ├── Shell Aliases
    ├── Navigation Tools
    └── Utility Functions
```

### Key Components

1. **Configuration Module**
   - Define document structure
   - Set base directory
   - Configure shell integration

2. **Validation System**
   - Enforce Johnny Decimal rules
   - Validate structure
   - Prevent errors

3. **Directory Management**
   - Create directory structure
   - Maintain permissions
   - Handle updates

## Use Cases

### Personal Document Management
- Organize personal files
- Manage financial documents
- Track health records

### Professional Organization
- Project documentation
- Client files
- Administrative documents

### Academic Use
- Research papers
- Data organization
- Study materials

### Creative Projects
- Writing projects
- Design files
- Media organization

## Future Development

### Planned Features
1. **Enhanced Integration**
   - Git integration
   - Cloud sync support
   - Additional shell tools

2. **Advanced Features**
   - Search functionality
   - Metadata management
   - Tagging system

3. **User Interface**
   - CLI tools
   - TUI interface
   - Status reporting

### Community Involvement

We welcome:
- Feature requests
- Bug reports
- Code contributions
- Documentation improvements

## Project Philosophy

1. **Simplicity**
   - Clear configuration
   - Straightforward usage
   - Minimal dependencies

2. **Reliability**
   - Thorough validation
   - Safe operations
   - Consistent behavior

3. **Extensibility**
   - Modular design
   - Plugin system
   - Custom integrations

## Getting Involved

### Ways to Contribute
- Code contributions
- Documentation
- Bug reports
- Feature requests

### Community
- GitHub discussions
- Issue tracker
- Pull requests

## License

Johnny-Mnemonix is released under the MIT License. See the LICENSE file for details.

================
File: docs/api.md
================
# API Documentation

This document describes the programmatic interfaces available in Johnny-Mnemonix.

## Nix API

### Core Functions

```nix
# Library functions for structure manipulation
{
  # Create a new area
  mkArea = { id, name, categories ? {} }:
    assert validateAreaId id;
    {
      inherit id name categories;
    };

  # Create a new category
  mkCategory = { id, name, items ? {} }:
    assert validateCategoryId id;
    {
      inherit id name items;
    };

  # Create a new item
  mkItem = { id, name }:
    assert validateItemId id;
    {
      inherit id name;
    };
}
```

### Validation Functions

```nix
{
  # Validate area ID format (XX-YY)
  validateAreaId = id: builtins.match "^[0-9]{2}-[0-9]{2}$" id != null;

  # Validate category ID format (XX)
  validateCategoryId = id: builtins.match "^[0-9]{2}$" id != null;

  # Validate item ID format (XX.YY)
  validateItemId = id: builtins.match "^[0-9]{2}[.][0-9]{2}$" id != null;
}
```

### Path Manipulation

```nix
{
  # Create full path for an item
  makePath = { baseDir, areaId, areaName, categoryId, categoryName, itemId, itemName }:
    "${baseDir}/${areaId} ${areaName}/${categoryId} ${categoryName}/${itemId} ${itemName}";

  # Sanitize path components
  sanitizePath = path: builtins.replaceStrings [" "] ["\\\ "] path;
}
```

## Plugin API

### Plugin Interface

```nix
# Plugin module interface
{
  # Plugin configuration options
  options.johnny-mnemonix.plugins.<name> = {
    enable = mkEnableOption "Enable the plugin";
    
    # Plugin-specific options
    config = mkOption {
      type = types.attrs;
      default = {};
      description = "Plugin configuration";
    };
  };

  # Plugin implementation
  config = mkIf cfg.enable {
    # Plugin functionality
  };
}
```

### Event Hooks

```nix
{
  # Directory creation hooks
  hooks.beforeCreate = path: {
    # Pre-creation actions
  };

  hooks.afterCreate = path: {
    # Post-creation actions
  };

  # Structure validation hooks
  hooks.beforeValidate = structure: {
    # Pre-validation actions
  };

  hooks.afterValidate = structure: {
    # Post-validation actions
  };
}
```

## Shell Integration API

### Shell Functions

```bash
# Available shell functions
{
  # Navigate to document root
  jd() {
    cd "${JOHNNY_MNEMONIX_BASE:-$HOME/Documents}"
  }

  # Navigate to specific area/category/item
  jj() {
    local code="$1"
    case "$code" in
      [0-9][0-9]-[0-9][0-9]) _jj_area "$code" ;;
      [0-9][0-9]) _jj_category "$code" ;;
      [0-9][0-9].[0-9][0-9]) _jj_item "$code" ;;
      *) echo "Invalid code format" ;;
    esac
  }
}
```

## Configuration API

### Module Options

```nix
{
  options.johnny-mnemonix = {
    # Basic options
    enable = mkEnableOption "Enable Johnny-Mnemonix";
    
    baseDir = mkOption {
      type = types.str;
      description = "Base directory for document structure";
    };

    # Structure definition
    areas = mkOption {
      type = types.attrsOf (types.submodule {
        options = {
          name = mkOption {
            type = types.str;
            description = "Area name";
          };
          categories = mkOption {
            type = types.attrsOf (types.submodule {
              options = {
                name = mkOption {
                  type = types.str;
                  description = "Category name";
                };
                items = mkOption {
                  type = types.attrsOf (types.submodule {
                    options = {
                      name = mkOption {
                        type = types.str;
                        description = "Item name";
                      };
                    };
                  });
                  default = {};
                  description = "Category items";
                };
              };
            });
            default = {};
            description = "Area categories";
          };
        };
      });
      default = {};
      description = "Document structure areas";
    };
  };
}
```

================
File: docs/configuration.md
================
# Configuration Guide

This guide explains how to configure Johnny-Mnemonix for your document management needs.

## Basic Configuration

The minimal configuration requires:
1. Enabling the module
2. Defining at least one area

```nix
{
  johnny-mnemonix = {
    enable = true;
    areas = {
      "10-19" = {
        name = "Personal";
        categories = {
          "11" = {
            name = "Finance";
            items = {
              "11.01" = "Budget";
            };
          };
        };
      };
    };
  };
}
```

## Configuration Options

### Top-Level Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enable` | boolean | `false` | Enable Johnny Mnemonix |
| `baseDir` | string | `"$HOME/Documents"` | Base directory for document structure |

### Area Configuration

Areas must follow these rules:
- IDs must be in format `XX-YY` (e.g., "10-19")
- Names should be descriptive
- Areas should be logically grouped (e.g., 10-19 for Personal, 20-29 for Work)

Example:
```nix
areas = {
  "10-19" = {
    name = "Personal";
    categories = { ... };
  };
};
```

### Category Configuration

Categories must follow these rules:
- IDs must be two digits (e.g., "11")
- IDs should fall within their parent area's range
- Names should be clear and specific

Example:
```nix
categories = {
  "11" = {
    name = "Finance";
    items = { ... };
  };
};
```

### Item Configuration

Items must follow these rules:
- IDs must be in format `XX.YY` (e.g., "11.01")
- First two digits must match parent category
- Names should be specific and descriptive

Example:
```nix
items = {
  "11.01" = "Budget";
  "11.02" = "Investments";
};
```

## Shell Integration

Johnny-Mnemonix provides shell aliases for easy navigation:

| Alias | Description |
|-------|-------------|
| `jd` | Navigate to document root |

## Best Practices

1. **Consistent Naming**
   - Use clear, descriptive names
   - Maintain consistent naming conventions
   - Avoid special characters in names

2. **Logical Organization**
   - Group related items together
   - Use areas for broad categories
   - Use categories for specific groupings

3. **ID Management**
   - Keep IDs sequential when possible
   - Leave gaps for future additions
   - Follow the XX-YY format strictly

4. **Directory Structure**
   - Don't manually modify created directories
   - Use the configuration to make changes
   - Keep the structure flat (max 3 levels)

## Examples

See the [examples](../examples) directory for complete configuration examples:
- [Basic Configuration](../examples/basic/flake.nix)
- [Full Configuration](../examples/full/flake.nix)

================
File: docs/examples.md
================
# Johnny-Mnemonix Examples

This document provides practical examples and use cases for organizing your documents with Johnny-Mnemonix.

## Common Structures

### Personal Document Structure
```nix
{
  johnny-mnemonix = {
    enable = true;
    areas = {
      "10-19" = {
        name = "Personal";
        categories = {
          "11" = {
            name = "Finance";
            items = {
              "11.01" = "Budget";
              "11.02" = "Investments";
              "11.03" = "Tax Returns";
              "11.04" = "Insurance";
            };
          };
          "12" = {
            name = "Health";
            items = {
              "12.01" = "Medical Records";
              "12.02" = "Prescriptions";
              "12.03" = "Fitness Plans";
            };
          };
          "13" = {
            name = "Housing";
            items = {
              "13.01" = "Lease Agreements";
              "13.02" = "Maintenance Records";
              "13.03" = "Utilities";
            };
          };
        };
      };
    };
  };
}
```

### Work Document Structure
```nix
{
  "20-29" = {
    name = "Work";
    categories = {
      "21" = {
        name = "Projects";
        items = {
          "21.01" = "Active Projects";
          "21.02" = "Project Planning";
          "21.03" = "Project Templates";
        };
      };
      "22" = {
        name = "Admin";
        items = {
          "22.01" = "Contracts";
          "22.02" = "HR Documents";
          "22.03" = "Expenses";
        };
      };
      "23" = {
        name = "Client Work";
        items = {
          "23.01" = "Client A";
          "23.02" = "Client B";
          "23.03" = "Client Templates";
        };
      };
    };
  };
}
```

## Use Cases

### Academic Research
```nix
{
  "30-39" = {
    name = "Research";
    categories = {
      "31" = {
        name = "Literature";
        items = {
          "31.01" = "Papers";
          "31.02" = "References";
          "31.03" = "Notes";
        };
      };
      "32" = {
        name = "Data";
        items = {
          "32.01" = "Raw Data";
          "32.02" = "Processed Data";
          "32.03" = "Analysis Scripts";
        };
      };
      "33" = {
        name = "Writing";
        items = {
          "33.01" = "Drafts";
          "33.02" = "Figures";
          "33.03" = "Submissions";
        };
      };
    };
  };
}
```

### Creative Projects
```nix
{
  "40-49" = {
    name = "Creative";
    categories = {
      "41" = {
        name = "Writing";
        items = {
          "41.01" = "Stories";
          "41.02" = "Blog Posts";
          "41.03" = "Ideas";
        };
      };
      "42" = {
        name = "Design";
        items = {
          "42.01" = "Artwork";
          "42.02" = "References";
          "42.03" = "Templates";
        };
      };
    };
  };
}
```

## Tips for Structure Design

1. **Area Planning (XX-YY)**
   - 10-19: Personal
   - 20-29: Work
   - 30-39: Projects
   - 40-49: Creative
   - 90-99: Archive

2. **Category Organization (XX)**
   - Use first digit for broad grouping
   - Leave space for future categories
   - Keep related items together

3. **Item Numbering (XX.YY)**
   - Start with .01 for most important/common items
   - Leave gaps for future additions
   - Use consistent naming patterns

## Migration Strategy

When moving from an existing document structure:

1. **Analysis**
   - List all existing directories
   - Identify natural groupings
   - Note access patterns

2. **Planning**
   - Assign area codes (XX-YY)
   - Create categories (XX)
   - Map existing folders to items (XX.YY)

3. **Implementation**
   ```nix
   {
     johnny-mnemonix = {
       enable = true;
       # Define structure based on analysis
       areas = {
         "10-19" = {
           name = "Existing Directory A";
           categories = {
             "11" = {
               name = "Subfolder 1";
               items = {
                 "11.01" = "Important Files";
               };
             };
           };
         };
       };
     };
   }
   ```

4. **Migration**
   - Create new structure with Johnny-Mnemonix
   - Move files gradually
   - Update references as needed

## Advanced Usage

### Custom Base Directory
```nix
{
  johnny-mnemonix = {
    enable = true;
    baseDir = "/data/documents";
    # ... rest of configuration
  };
}
```

### Multiple Area Groups
```nix
{
  areas = {
    "10-19" = { name = "Personal"; };
    "20-29" = { name = "Work"; };
    "30-39" = { name = "Projects"; };
    "40-49" = { name = "Creative"; };
    "90-99" = { name = "Archive"; };
  };
}
```

## Common Patterns

1. **Time-Based Organization**
   ```nix
   "31" = {
     name = "Archives";
     items = {
       "31.01" = "2024";
       "31.02" = "2023";
       "31.03" = "2022";
     };
   };
   ```

2. **Project States**
   ```nix
   "21" = {
     name = "Projects";
     items = {
       "21.01" = "Active";
       "21.02" = "Planning";
       "21.03" = "Completed";
     };
   };
   ```

3. **Client Organization**
   ```nix
   "23" = {
     name = "Clients";
     items = {
       "23.01" = "Onboarding";
       "23.02" = "Active";
       "23.03" = "Archive";
     };
   };
   ```

================
File: docs/faq.md
================
# Frequently Asked Questions

## General Questions

### What is Johnny-Mnemonix?
Johnny-Mnemonix is a declarative document management system built on the Johnny Decimal system, implemented as a Nix Home Manager module. It helps you organize your documents in a consistent, maintainable way using a numeric system for easy reference and navigation.

### Why use Johnny-Mnemonix?
- **Declarative Configuration**: Your document structure is defined in code
- **Version Control**: Track changes to your organization system
- **Reproducible**: Easy to recreate on different machines
- **Consistent**: Enforces Johnny Decimal system rules
- **Extensible**: Plugin system for additional functionality

### How does it differ from regular folders?
1. **Structure Validation**: Enforces correct naming and organization
2. **Automated Creation**: Generates directory structure from configuration
3. **Shell Integration**: Quick navigation using numeric codes
4. **Plugin System**: Extensible functionality
5. **Version Control**: Track structural changes

## Setup and Installation

### How do I install Johnny-Mnemonix?
```nix
# flake.nix
{
  inputs.johnny-mnemonix.url = "github:lessuselesss/johnny-mnemonix";
  
  outputs = { self, nixpkgs, home-manager, johnny-mnemonix }: {
    homeConfigurations."user" = home-manager.lib.homeManagerConfiguration {
      # ...
      modules = [
        johnny-mnemonix.homeManagerModules.default
        # ...
      ];
    };
  };
}
```

### What are the system requirements?
- Nix package manager
- Home Manager
- Linux or macOS
- Basic understanding of the Johnny Decimal system

### Can I use it without Nix?
No, Johnny-Mnemonix is specifically designed as a Nix Home Manager module to leverage the benefits of declarative configuration and reproducible builds.

## Usage Questions

### How do I start organizing my documents?

1. Plan your areas (XX-YY):
```nix
areas = {
  "10-19" = { name = "Personal"; };
  "20-29" = { name = "Work"; };
};
```

2. Define categories (XX):
```nix
"10-19" = {
  name = "Personal";
  categories = {
    "11" = { name = "Finance"; };
    "12" = { name = "Health"; };
  };
};
```

3. Add items (XX.YY):
```nix
"11" = {
  name = "Finance";
  items = {
    "11.01" = "Budget";
    "11.02" = "Investments";
  };
};
```

### How do I navigate the structure?

Use the provided shell commands:
```bash
# Go to document root
jd

# Go to specific area/category/item
jj 10-19    # Go to Personal area
jj 11       # Go to Finance category
jj 11.01    # Go to Budget item
```

### Can I rename directories?
Don't rename directories manually. Instead, update your configuration:

```nix
# Before
"11.01" = "Budget";

# After
"11.01" = "Monthly Budget";
```

Then run `home-manager switch` to apply changes.

## Structure Questions

### How many areas should I create?
- Start with 3-5 main areas
- Leave gaps for future expansion
- Common structure:
  - 10-19: Personal
  - 20-29: Work
  - 30-39: Projects
  - 90-99: Archive

### What's the maximum depth?
The Johnny Decimal system uses three levels:
1. Areas (XX-YY)
2. Categories (XX)
3. Items (XX.YY)

### Can I move items between categories?
Yes, update your configuration:
```nix
# Before
"11" = {
  items."11.01" = "Budget";
};

# After
"12" = {
  items."12.01" = "Budget";
};
```

## Plugin Questions

### How do I enable plugins?
```nix
{
  johnny-mnemonix = {
    enable = true;
    plugins = {
      tags.enable = true;
      sync.enable = true;
    };
  };
}
```

### Can I write my own plugins?
Yes, create a plugin module:
```nix
# plugins/my-plugin/default.nix
{ config, lib, ... }: {
  options.johnny-mnemonix.plugins.my-plugin = {
    enable = lib.mkEnableOption "My plugin";
  };
  
  config = lib.mkIf config.johnny-mnemonix.plugins.my-plugin.enable {
    # Plugin implementation
  };
}
```

## Troubleshooting

### Why aren't my directories created?
1. Check module is enabled:
```nix
johnny-mnemonix.enable = true;
```

2. Verify configuration syntax
3. Check permissions
4. Run with verbose output:
```bash
home-manager switch -v
```

### How do I fix permission errors?
1. Check directory ownership:
```bash
ls -la ~/Documents
```

2. Fix permissions:
```bash
chmod 755 ~/Documents
```

3. Update configuration:
```nix
johnny-mnemonix.security.defaultPermissions = "0755";
```

### Why are my changes not applying?
1. Run `home-manager switch`
2. Check configuration changes
3. Verify no manual changes
4. Check error messages

## Migration

### How do I migrate existing documents?
1. Plan your structure
2. Create configuration
3. Move files gradually:
```bash
# Example migration script
for dir in ~/OldDocs/*; do
  # Move to appropriate JD location
  mv "$dir" ~/Documents/10-19\ Personal/11\ Finance/
done
```

### Can I import existing structures?
Yes, map your existing structure to Johnny Decimal:
1. Analyze current organization
2. Create mapping document
3. Configure Johnny-Mnemonix
4. Migrate files

## Best Practices

### Should I version

================
File: docs/integration.md
================
# Integration Guide

This guide explains how to integrate Johnny-Mnemonix with other tools and workflows.

## Shell Integration

### Bash/Zsh Functions

Add these helpful functions to your shell configuration:

```bash
# ~/.bashrc or ~/.zshrc

# Quick navigation using Johnny Decimal codes
jj() {
  local code="$1"
  local base_dir="${JOHNNY_MNEMONIX_BASE:-$HOME/Documents}"
  
  # Pattern matching for different code formats
  case "$code" in
    # Area navigation (e.g., 10)
    [0-9][0-9])
      cd "$base_dir"/*"$code-"* 2>/dev/null || echo "Area not found: $code"
      ;;
    # Category navigation (e.g., 11)
    [0-9][0-9].[0-9][0-9])
      cd "$base_dir"/*/*"$code "* 2>/dev/null || echo "Category not found: $code"
      ;;
    # Item navigation (e.g., 11.01)
    [0-9][0-9].[0-9][0-9])
      cd "$base_dir"/*/*/*"$code "* 2>/dev/null || echo "Item not found: $code"
      ;;
    *)
      echo "Invalid Johnny Decimal code format"
      echo "Usage: jj XX (area) or XX.YY (category) or XX.YY (item)"
      ;;
  esac
}

# List structure with tree
jls() {
  tree -L 3 --noreport "${JOHNNY_MNEMONIX_BASE:-$HOME/Documents}" | \
    grep -E "^[│├└].+[0-9]{2}(-[0-9]{2}| [A-Za-z])"
}

# Search within Johnny Decimal structure
jf() {
  local search_term="$1"
  find "${JOHNNY_MNEMONIX_BASE:-$HOME/Documents}" -type f -name "*$search_term*" | \
    grep -E "/[0-9]{2}(-[0-9]{2}|.[0-9]{2})"
}
```

### Fish Functions

```fish
# ~/.config/fish/functions/jj.fish
function jj
  set -l code $argv[1]
  set -l base_dir $JOHNNY_MNEMONIX_BASE; or set base_dir $HOME/Documents
  
  switch $code
    case '[0-9][0-9]'
      cd $base_dir/*$code-* 2>/dev/null; or echo "Area not found: $code"
    case '[0-9][0-9].[0-9][0-9]'
      cd $base_dir/*/*$code* 2>/dev/null; or echo "Category not found: $code"
    case '[0-9][0-9].[0-9][0-9]'
      cd $base_dir/*/*/*$code* 2>/dev/null; or echo "Item not found: $code"
    case '*'
      echo "Invalid Johnny Decimal code format"
      echo "Usage: jj XX (area) or XX.YY (category) or XX.YY (item)"
  end
end
```

## Git Integration

### Git Ignore Template

```gitignore
# ~/.config/johnny-mnemonix/templates/gitignore
# Temporary files
*.tmp
*.temp
.DS_Store

# Build artifacts
*.pdf
*.docx
*.xlsx

# Local configuration
.johnny-local
```

### Git Attributes

```gitattributes
# ~/.config/johnny-mnemonix/templates/gitattributes
# Handle line endings automatically for text files
* text=auto

# Documents
*.md text
*.txt text
*.doc binary
*.docx binary
*.pdf binary
```

## Syncthing Integration

Example Syncthing configuration for your Johnny Decimal structure:

```nix
{
  services.syncthing = {
    enable = true;
    folders = {
      documents = {
        path = "${config.johnny-mnemonix.baseDir}";
        devices = [ "laptop" "desktop" ];
        versioning = {
          type = "simple";
          params.keep = "5";
        };
      };
    };
  };
}
```

## Backup Integration

### Restic Example

```nix
{
  services.restic.backups = {
    documents = {
      paths = [ "${config.johnny-mnemonix.baseDir}" ];
      repository = "rclone:gdrive:backup/documents";
      passwordFile = "/run/secrets/restic-password";
      initialize = true;
      timerConfig = {
        OnCalendar = "daily";
      };
    };
  };
}
```

## Editor Integration

### VS Code Workspace Settings

```jsonc
// .vscode/settings.json
{
  "files.exclude": {
    "**/*.tmp": true,
    "**/*.temp": true
  },
  "search.exclude": {
    "**/node_modules": true,
    "**/bower_components": true
  },
  "files.associations": {
    "*.jd": "markdown" // Johnny Decimal metadata files
  }
}
```

### Neovim Configuration

```lua
-- ~/.config/nvim/after/plugin/johnny.lua
local johnny = {}

-- Quick navigation using telescope
johnny.find_document = function()
  require('telescope.builtin').find_files({
    prompt_title = "Johnny Decimal Documents",
    cwd = os.getenv("JOHNNY_MNEMONIX_BASE") or (os.getenv("HOME") .. "/Documents"),
    file_ignore_patterns = {
      "*.tmp", "*.temp", ".DS_Store"
    }
  })
end

-- Key mappings
vim.keymap.set('n', '<leader>jd', johnny.find_document, {
  desc = "Find in Johnny Decimal structure"
})
```

## CLI Tools Integration

### FZF Integration

```bash
# Quick document fuzzy finding
jfzf() {
  local base_dir="${JOHNNY_MNEMONIX_BASE:-$HOME/Documents}"
  local selected=$(find "$base_dir" -type f | \
    grep -E "/[0-9]{2}(-[0-9]{2}|.[0-9]{2})" | \
    fzf --prompt="Johnny Decimal Documents" --preview="cat {}")
  if [ -n "$selected" ]; then
    nvim "$selected"
  fi
}
```

================
File: docs/migration.md
================
# Migration Guide

This guide helps you migrate your existing document structure to Johnny-Mnemonix.

## Planning Your Migration

### 1. Analyze Current Structure

First, analyze your existing document structure:

```bash
# List current directory structure
tree -L 3 ~/Documents > current_structure.txt

# Get file statistics
find ~/Documents -type f | \
  grep -v '^\.' | \
  awk -F/ '{print $(NF-1)}' | \
  sort | uniq -c > file_stats.txt
```

### 2. Map to Johnny Decimal

Create a mapping table:

| Current Directory | Johnny Decimal Code | Description |
|------------------|---------------------|-------------|
| Financial/       | 10-19              | Personal Finance |
| Bills/          | 11                  | Regular Bills |
| Statements/     | 11.01              | Bank Statements |

### 3. Create Configuration

Based on your mapping, create your Johnny-Mnemonix configuration:

```nix
{
  johnny-mnemonix = {
    enable = true;
    areas = {
      "10-19" = {
        name = "Personal Finance";
        categories = {
          "11" = {
            name = "Regular Bills";
            items = {
              "11.01" = "Bank Statements";
            };
          };
        };
      };
    };
  };
}
```

## Migration Strategies

### 1. Gradual Migration

Migrate files gradually while maintaining both structures:

```bash
#!/usr/bin/env bash
# migrate.sh

source_dir="$HOME/Documents/Old"
target_dir="$HOME/Documents"

# Function to migrate a directory
migrate_directory() {
  local source="$1"
  local target="$2"
  local jd_code="$3"
  
  echo "Migrating $source to $target/$jd_code"
  
  # Create target directory if it doesn't exist
  mkdir -p "$target/$jd_code"
  
  # Copy files
  cp -rv "$source/"* "$target/$jd_code/"
  
  # Create migration log
  echo "$(date): Migrated $source to $jd_code" >> migration.log
}

# Example usage
migrate_directory "$source_dir/Financial/Bills" \
                 "$target_dir" \
                 "11 Regular Bills"
```

### 2. Complete Migration

For a one-time complete migration:

```bash
#!/usr/bin/env bash
# full_migrate.sh

source_dir="$HOME/Documents"
backup_dir="$HOME/Documents_Backup_$(date +%Y%m%d)"
target_dir="$HOME/Documents_New"

# Backup existing structure
cp -r "$source_dir" "$backup_dir"

# Create new structure
home-manager switch

# Migrate files according to mapping
while IFS=, read -r old_path jd_code description; do
  # Skip header
  [[ $old_path == "Old Path" ]] && continue
  
  # Create target directory
  mkdir -p "$target_dir/$jd_code"
  
  # Move files
  find "$source_dir/$old_path" -type f -exec mv {} "$target_dir/$jd_code/" \;
  
  echo "Migrated: $old_path → $jd_code"
done < mapping.csv
```

## Post-Migration Tasks

### 1. Verify Migration

```bash
#!/usr/bin/env bash
# verify_migration.sh

# Check file counts
old_count=$(find "$backup_dir" -type f | wc -l)
new_count=$(find "$target_dir" -type f | wc -l)

echo "Old structure: $old_count files"
echo "New structure: $new_count files"

# Check for orphaned files
find "$target_dir" -type f | \
  grep -vE "/[0-9]{2}(-[0-9]{2}|.[0-9]{2})" > orphaned_files.txt

# Verify file integrity
find "$target_dir" -type f -exec md5sum {} \; > new_checksums.txt
```

### 2. Update References

Update any references to the old structure:

```bash
# Find files containing old paths
grep -r "/old/path" "$HOME" > references.txt

# Update shell aliases
sed -i 's|OLD_DOCS=.*|OLD_DOCS='"$target_dir"'|g' ~/.bashrc
```

### 3. Clean Up

```bash
#!/usr/bin/env bash
# cleanup.sh

# Remove empty directories from old structure
find "$source_dir" -type d -empty -delete

# Remove temporary migration files
rm -f migration.log orphaned_files.txt new_checksums.txt

# Keep backup for safety period
echo "Backup stored at: $backup_dir"
echo "Can be removed after verification period"
```

## Best Practices

1. **Backup First**
   - Always create backups before migration
   - Verify backup integrity
   - Keep backups until migration is verified

2. **Document Everything**
   - Create detailed mapping documentation
   - Log all migration steps
   - Document any special cases

3. **Test Migration**
   - Test with a subset of files first
   - Verify file integrity
   - Check permissions and ownership

4. **Handle Edge Cases**
   - Document special file types
   - Note any symlinks or hardlinks
   - Handle hidden files appropriately

## Troubleshooting

### Common Issues

1. **Missing Files**
   ```bash
   # Find files not migrated
   comm -23 \
     <(find "$backup_dir" -type f | sort) \
     <(find "$target_dir" -type f | sort) \
     > missing_files.txt
   ```

2. **Permission Issues**
   ```bash
   # Fix permissions
   chmod -R u+rw "$target_dir"
   chown -R $USER:$USER "$target_dir"
   ```

3. **Broken Links**
   ```bash
   # Find broken symlinks
   find "$target_dir" -type l ! -exec test -e {} \; -print
   ```

### Recovery Steps

1. **Restore from Backup**
   ```bash
   # Restore specific files
   rsync -av --files-from=missing_files.txt \
     "$backup_dir/" "$target_dir/"
   ```

2. **Fix Structure**
   ```bash
   # Reorganize misplaced files
   find "$target_dir" -type f ! -path "*/[0-9][0-9]*/*" \
     -exec mv {} "$target_dir/99 Migration/" \;
   ```

Remember to take your time with the migration and verify each step carefully.

================
File: docs/performance.md
================
# Performance Guide

This document outlines performance considerations and optimization strategies for Johnny-Mnemonix.

## Performance Metrics

### Directory Structure Performance

```nix
{
  johnny-mnemonix = {
    performance = {
      # Enable performance monitoring
      monitoring = {
        enable = true;
        metrics = [
          "directory-creation-time"
          "structure-validation-time"
          "plugin-load-time"
        ];
        logFile = "/var/log/johnny-mnemonix/performance.log";
      };
      
      # Performance tuning
      tuning = {
        # Batch directory operations
        batchSize = 100;
        # Parallel directory creation
        parallel = true;
        maxThreads = 4;
      };
    };
  };
}
```

## Optimization Strategies

### 1. Directory Structure Optimization

```nix
{
  johnny-mnemonix = {
    optimization = {
      # Optimize directory structure
      structure = {
        # Pre-allocate common directories
        preallocation = true;
        # Cache directory listings
        cacheEnabled = true;
        cacheTimeout = 3600;
      };
    };
  };
}
```

### 2. Memory Usage

```nix
{
  performance = {
    memory = {
      # Maximum memory usage for operations
      maxMemory = "512M";
      # Cache settings
      cache = {
        enable = true;
        size = "128M";
        ttl = 3600;
      };
    };
  };
}
```

## Benchmarking

### Directory Operations Benchmark

```bash
#!/usr/bin/env bash

# benchmark.sh
start_time=$(date +%s.%N)

# Create test structure
home-manager switch

end_time=$(date +%s.%N)
creation_time=$(echo "$end_time - $start_time" | bc)

echo "Directory structure creation time: $creation_time seconds"
```

### Performance Testing Script

```bash
#!/usr/bin/env bash

# performance-test.sh

# Test directory creation speed
test_creation_speed() {
  local count=$1
  local start_time=$(date +%s.%N)
  
  for i in $(seq 1 $count); do
    mkdir -p "test/area-$i/category-$i/item-$i"
  done
  
  local end_time=$(date +%s.%N)
  echo "Created $count directories in $(echo "$end_time - $start_time" | bc) seconds"
}

# Test structure validation speed
test_validation_speed() {
  local start_time=$(date +%s.%N)
  home-manager check
  local end_time=$(date +%s.%N)
  echo "Structure validation time: $(echo "$end_time - $start_time" | bc) seconds"
}

# Run tests
test_creation_speed 1000
test_validation_speed
```

## Performance Monitoring

### System Metrics

```nix
{
  johnny-mnemonix = {
    monitoring = {
      metrics = {
        enable = true;
        prometheus = {
          enable = true;
          port = 9090;
        };
        grafana = {
          enable = true;
          port = 3000;
        };
      };
    };
  };
}
```

### Performance Dashboard

```nix
{
  services.grafana.dashboards.johnny-mnemonix = {
    folder = "Johnny-Mnemonix";
    settings = {
      annotations.list = [];
      editable = true;
      panels = [
        {
          title = "Directory Creation Time";
          type = "graph";
          datasource = "Prometheus";
        }
        {
          title = "Structure Validation Time";
          type = "graph";
          datasource = "Prometheus";
        }
      ];
    };
  };
}
```

## Optimization Guidelines

### 1. Directory Structure

- Keep directory depth minimal
- Use consistent naming patterns
- Avoid special characters
- Limit directory size

### 2. Resource Usage

- Monitor memory usage
- Control disk I/O
- Manage cache size
- Limit concurrent operations

### 3. Plugin Performance

- Profile plugin operations
- Cache plugin results
- Lazy load plugins
- Optimize plugin configurations

## Performance Troubleshooting

### Common Issues

1. **Slow Directory Creation**
   - Check disk I/O
   - Monitor system resources
   - Verify permissions
   - Check for filesystem issues

2. **High Memory Usage**
   - Monitor cache size
   - Check plugin memory usage
   - Verify configuration limits
   - Profile memory allocation

3. **Slow Validation**
   - Profile validation steps
   - Check regex performance
   - Monitor CPU usage
   - Optimize validation rules

### Diagnostic Tools

```bash
# Check directory creation performance
time home-manager switch

# Profile system resources
top -b -n 1 -p $(pgrep -f johnny-mnemonix)

# Monitor disk I/O
iostat -x 1

# Check filesystem performance
dd if=/dev/zero of=test bs=1M count=1000
```

## Best Practices

### 1. Structure Design
- Plan directory hierarchy carefully
- Use meaningful but concise names
- Keep structure balanced
- Allow for future growth

### 2. Resource Management
- Set appropriate limits
- Monitor resource usage
- Use caching effectively
- Optimize operations

### 3. Maintenance
- Regular performance checks
- Clean up unused directories
- Update configurations
- Monitor metrics

## Performance Checklist

### Initial Setup
- [ ] Configure performance monitoring
- [ ] Set resource limits
- [ ] Enable caching
- [ ] Configure metrics collection

### Regular Maintenance
- [ ] Review performance logs
- [ ] Check resource usage
- [ ] Optimize structure
- [ ] Update configurations

### Optimization Steps
1. Monitor current performance
2. Identify bottlenecks
3. Implement improvements
4. Measure results
5. Iterate as needed

================
File: docs/plugins.md
================
# Plugin System

Johnny-Mnemonix supports plugins to extend its functionality. This guide explains how to create, use, and manage plugins.

## Plugin Architecture

### Plugin Structure
```
plugins/
├── my-plugin/
│   ├── default.nix
│   ├── lib/
│   │   └── functions.nix
│   └── module.nix
```

### Basic Plugin Template

```nix
# plugins/my-plugin/default.nix
{ lib, config, ... }:

with lib;
let
  cfg = config.johnny-mnemonix.plugins.my-plugin;
in {
  options.johnny-mnemonix.plugins.my-plugin = {
    enable = mkEnableOption "My Johnny-Mnemonix Plugin";
    
    # Plugin-specific options
    setting = mkOption {
      type = types.str;
      default = "default value";
      description = "Example plugin setting";
    };
  };

  config = mkIf cfg.enable {
    # Plugin implementation
  };
}
```

## Creating Plugins

### 1. Basic Plugin

```nix
# plugins/tags/default.nix
{ lib, config, ... }:

with lib;
let
  cfg = config.johnny-mnemonix.plugins.tags;
in {
  options.johnny-mnemonix.plugins.tags = {
    enable = mkEnableOption "Document tagging support";
    
    tags = mkOption {
      type = types.attrsOf types.str;
      default = {};
      description = "Document tags";
    };
  };

  config = mkIf cfg.enable {
    # Implementation
  };
}
```

### 2. Advanced Plugin

```nix
# plugins/sync/default.nix
{ lib, config, pkgs, ... }:

with lib;
let
  cfg = config.johnny-mnemonix.plugins.sync;
in {
  options.johnny-mnemonix.plugins.sync = {
    enable = mkEnableOption "Document synchronization";
    
    provider = mkOption {
      type = types.enum [ "rclone" "syncthing" "rsync" ];
      default = "rclone";
      description = "Sync provider to use";
    };

    target = mkOption {
      type = types.str;
      description = "Sync target location";
    };

    schedule = mkOption {
      type = types.str;
      default = "hourly";
      description = "Sync schedule";
    };
  };

  config = mkIf cfg.enable {
    systemd.user.services.johnny-sync = {
      Unit = {
        Description = "Johnny-Mnemonix document sync";
      };
      Service = {
        ExecStart = "${pkgs.rclone}/bin/rclone sync ${cfg.source} ${cfg.target}";
      };
      Install = {
        WantedBy = [ "default.target" ];
      };
    };
  };
}
```

## Using Plugins

### Configuration Example

```nix
{
  johnny-mnemonix = {
    enable = true;
    plugins = {
      tags.enable = true;
      sync = {
        enable = true;
        provider = "rclone";
        target = "gdrive:backup";
      };
    };
  };
}
```

## Plugin Categories

### 1. Organization Plugins
- Tagging systems
- Metadata management
- Custom categorization

### 2. Integration Plugins
- Cloud storage sync
- Version control
- Backup solutions

### 3. Utility Plugins
- Search enhancements
- Statistics
- Health checks

## Plugin Development Guidelines

### 1. Best Practices
- Follow Nix coding style
- Provide clear documentation
- Include usage examples
- Add proper error handling

### 2. Testing
```nix
# tests/default.nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.nixosTest {
  name = "my-plugin-test";
  
  nodes.machine = { config, pkgs, ... }: {
    imports = [ ./my-plugin ];
    johnny-mnemonix.plugins.my-plugin.enable = true;
  };
  
  testScript = ''
    machine.wait_for_unit("my-plugin.service")
    machine.succeed("test -d /path/to/expected/directory")
  '';
}
```

### 3. Documentation
```markdown
# Plugin Documentation Template

## Overview
Brief description of the plugin's purpose

## Configuration
Available options and their meanings

## Examples
Usage examples and common patterns

## Troubleshooting
Common issues and solutions
```

## Official Plugins

### Core Plugins
1. **Tags Plugin**
   - Document tagging
   - Tag-based search
   - Tag management

2. **Sync Plugin**
   - Multi-provider sync
   - Scheduled syncing
   - Conflict resolution

3. **Stats Plugin**
   - Usage statistics
   - Storage analysis
   - Health reporting

### Community Plugins

Guidelines for community plugins:
1. Use semantic versioning
2. Provide clear documentation
3. Include test cases
4. Follow security guidelines

## Plugin Security

### Guidelines
1. Validate all inputs
2. Use secure defaults
3. Document security implications
4. Follow principle of least privilege

### Example Security Check
```nix
# Security validation in plugin
validateConfig = config:
  assert config.target != "/";  # Prevent root access
  assert hasPrefix "backup:" config.target;  # Enforce naming
  config;
```

## Plugin Maintenance

### Version Management
```nix
# plugin/version.nix
{
  version = "1.0.0";
  compatibleVersions = [ "0.1.0" "0.2.0" ];
  
  assertCompatible = currentVersion:
    assert builtins.elem currentVersion compatibleVersions;
    true;
}
```

### Update Process
1. Test changes
2. Update version
3. Update documentation
4. Create changelog
5. Submit PR

## Contributing Plugins

1. Fork repository
2. Create plugin directory
3. Add documentation
4. Submit pull request

See [CONTRIBUTING.md](../CONTRIBUTING.md) for detailed guidelines.

================
File: docs/security.md
================
# Security Guidelines

This document outlines security considerations and best practices for using Johnny-Mnemonix.

## File System Security

### Directory Permissions

Default permissions are set to ensure proper security:

```nix
{
  johnny-mnemonix = {
    security = {
      defaultPermissions = "0750";  # rwxr-x---
      baseDirectoryPermissions = "0755";  # rwxr-xr-x
      sensitiveDirectoryPermissions = "0700";  # rwx------
    };
  };
}
```

### Sensitive Data Handling

Mark directories containing sensitive data:

```nix
{
  areas = {
    "10-19" = {
      name = "Personal";
      categories = {
        "11" = {
          name = "Finance";
          sensitive = true;  # Applies stricter permissions
          items = {
            "11.01" = "Tax Returns";
          };
        };
      };
    };
  };
}
```

## Access Control

### User Permissions

```nix
{
  johnny-mnemonix = {
    security = {
      users = {
        alice = {
          areas = [ "10-19" "20-29" ];
          permissions = "rw";
        };
        bob = {
          areas = [ "20-29" ];
          permissions = "r";
        };
      };
    };
  };
}
```

### Group Management

```nix
{
  security = {
    groups = {
      finance = {
        members = [ "alice" "bob" ];
        areas = [ "10-19" ];
        permissions = "r";
      };
      projects = {
        members = [ "alice" "charlie" ];
        areas = [ "20-29" ];
        permissions = "rw";
      };
    };
  };
}
```

## Encryption

### Directory Encryption

Using LUKS encryption for sensitive areas:

```nix
{
  johnny-mnemonix = {
    security = {
      encryption = {
        enable = true;
        areas = [ "10-19" ];  # Encrypt personal data
        method = "luks";
        keyFile = "/run/secrets/documents.key";
      };
    };
  };
}
```

### File-Level Encryption

Using age for file-level encryption:

```nix
{
  security = {
    fileEncryption = {
      enable = true;
      categories = [ "11" ];  # Encrypt finance category
      method = "age";
      publicKey = "age1...";
      recipientFile = "/etc/johnny-mnemonix/recipients.txt";
    };
  };
}
```

## Audit and Logging

### Access Logging

```nix
{
  johnny-mnemonix = {
    security = {
      audit = {
        enable = true;
        logAccess = true;
        logFile = "/var/log/johnny-mnemonix/access.log";
        retention = "30d";
      };
    };
  };
}
```

### Change Tracking

```nix
{
  security = {
    audit = {
      trackChanges = true;
      changeLog = "/var/log/johnny-mnemonix/changes.log";
      notifyChanges = true;
      notificationMethod = "email";
      notificationRecipient = "admin@example.com";
    };
  };
}
```

## Backup Security

### Secure Backups

```nix
{
  johnny-mnemonix = {
    security = {
      backup = {
        encryption = true;
        encryptionKey = "/run/secrets/backup.key";
        compressBackups = true;
        signBackups = true;
        signingKey = "/run/secrets/backup-signing.key";
      };
    };
  };
}
```

### Backup Verification

```nix
{
  security = {
    backup = {
      verifyBackups = true;
      verificationSchedule = "daily";
      keepVerificationLogs = true;
      verificationLogRetention = "90d";
    };
  };
}
```

## Network Security

### Remote Access

```nix
{
  johnny-mnemonix = {
    security = {
      network = {
        enableRemoteAccess = false;
        allowedIPs = [ "192.168.1.0/24" ];
        requireVPN = true;
        sshOnly = true;
      };
    };
  };
}
```

### Sync Security

```nix
{
  security = {
    sync = {
      encryptTransfer = true;
      verifyPeers = true;
      requireAuthentication = true;
      allowedProtocols = [ "sftp" "rsync+ssh" ];
    };
  };
}
```

## Best Practices

### 1. File System Security
- Use appropriate permissions
- Encrypt sensitive data
- Regularly audit permissions

### 2. Access Control
- Follow principle of least privilege
- Regularly review access
- Use strong authentication

### 3. Data Protection
- Encrypt sensitive data
- Secure backups
- Regular security audits

### 4. Network Security
- Limit remote access
- Use secure protocols
- Encrypt network traffic

## Security Checklist

### Initial Setup
- [ ] Configure base directory permissions
- [ ] Set up user/group permissions
- [ ] Enable encryption for sensitive data
- [ ] Configure audit logging
- [ ] Set up secure backups

### Regular Maintenance
- [ ] Review access logs
- [ ] Verify backup integrity
- [ ] Update encryption keys
- [ ] Audit permissions
- [ ] Check security settings

### Incident Response
1. Detect security events
2. Log all incidents
3. Notify administrators
4. Take corrective action
5. Update security measures

## Reporting Security Issues

If you discover a security vulnerability:

1. **Do Not** disclose publicly
2. Email security@johnny-mnemonix.example
3. Include detailed description
4. Await acknowledgment

## Security Updates

Stay informed about security updates:
- Subscribe to security notifications
- Monitor project releases
- Follow security advisories

================
File: docs/testing.md
================
# Testing Guide

This document outlines testing procedures and guidelines for Johnny-Mnemonix.

## Test Structure

```
tests/
├── default.nix          # Main test suite
├── unit/               # Unit tests
│   ├── validation.nix
│   └── permissions.nix
├── integration/        # Integration tests
│   ├── structure.nix
│   └── plugins.nix
└── fixtures/          # Test data
    └── sample-structure.nix
```

## Unit Tests

### Validation Tests

```nix
# tests/unit/validation.nix
{ pkgs ? import <nixpkgs> {} }:

let
  lib = import ../../lib { inherit pkgs; };
in
pkgs.lib.runTests {
  testValidAreaId = {
    expr = lib.schema.validate.areaId "10-19" "Personal";
    expected = true;
  };

  testInvalidAreaId = {
    expr = (lib.schema.validate.areaId "1019" "Invalid")
      or "invalid";
    expected = "invalid";
  };

  testValidCategoryId = {
    expr = lib.schema.validate.categoryId "11" "Finance";
    expected = true;
  };

  testValidItemId = {
    expr = lib.schema.validate.itemId "11.01" "Budget";
    expected = true;
  };
}
```

### Structure Tests

```nix
# tests/unit/structure.nix
{ pkgs ? import <nixpkgs> {} }:

let
  lib = import ../../lib { inherit pkgs; };
in
pkgs.lib.runTests {
  testCreateStructure = {
    expr = lib.utils.path.makeItemPath {
      baseDir = "/home/user/Documents";
      areaId = "10-19";
      areaName = "Personal";
      categoryId = "11";
      categoryName = "Finance";
      itemId = "11.01";
      itemName = "Budget";
    };
    expected = "/home/user/Documents/10-19 Personal/11 Finance/11.01 Budget";
  };
}
```

## Integration Tests

### Basic Structure Test

```nix
# tests/integration/structure.nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.nixosTest {
  name = "johnny-mnemonix-structure";

  nodes.machine = { config, pkgs, ... }: {
    imports = [ ../../modules ];
    
    johnny-mnemonix = {
      enable = true;
      baseDir = "/home/test/Documents";
      areas = {
        "10-19" = {
          name = "Personal";
          categories = {
            "11" = {
              name = "Finance";
              items = {
                "11.01" = "Budget";
              };
            };
          };
        };
      };
    };
  };

  testScript = ''
    machine.wait_for_unit("home-manager-test.service")
    machine.succeed("test -d /home/test/Documents/10-19\\ Personal")
    machine.succeed("test -d /home/test/Documents/10-19\\ Personal/11\\ Finance")
    machine.succeed("test -d /home/test/Documents/10-19\\ Personal/11\\ Finance/11.01\\ Budget")
  '';
}
```

### Plugin Tests

```nix
# tests/integration/plugins.nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.nixosTest {
  name = "johnny-mnemonix-plugins";

  nodes.machine = { config, pkgs, ... }: {
    imports = [ ../../modules ../../plugins/tags ];
    
    johnny-mnemonix = {
      enable = true;
      plugins.tags = {
        enable = true;
        tags = {
          "important" = "red";
          "archive" = "gray";
        };
      };
    };
  };

  testScript = ''
    machine.wait_for_unit("home-manager-test.service")
    machine.succeed("test -f /home/test/.config/johnny-mnemonix/tags.json")
  '';
}
```

## Performance Tests

```nix
# tests/performance/structure.nix
{ pkgs ? import <nixpkgs> {} }:

let
  lib = import ../../lib { inherit pkgs; };
  
  # Generate large test structure
  generateLargeStructure = count: 
    builtins.listToAttrs (builtins.genList (n: {
      name = "area-${toString n}";
      value = {
        categories = {
          "cat-${toString n}" = {
            items = {
              "item-${toString n}" = "Test Item ${toString n}";
            };
          };
        };
      };
    }) count);

in pkgs.nixosTest {
  name = "johnny-mnemonix-performance";

  nodes.machine = { config, pkgs, ... }: {
    imports = [ ../../modules ];
    
    johnny-mnemonix = {
      enable = true;
      areas = generateLargeStructure 1000;
    };
  };

  testScript = ''
    start_time = machine.succeed("date +%s.%N")
    machine.wait_for_unit("home-manager-test.service")
    end_time = machine.succeed("date +%s.%N")
    
    duration = float(end_time) - float(start_time)
    if duration > 5.0:
        raise Exception(f"Performance test failed: {duration}s > 5.0s")
  '';
}
```

## Running Tests

### All Tests
```bash
nix flake check
```

### Specific Tests
```bash
# Run unit tests
nix-build tests/unit

# Run integration tests
nix-build tests/integration

# Run performance tests
nix-build tests/performance
```

## Test Coverage

```nix
# tests/coverage.nix
{ pkgs ? import <nixpkgs> {} }:

let
  coverage = pkgs.nixosTest {
    name = "johnny-mnemonix-coverage";
    
    nodes.machine = { config, pkgs, ... }: {
      imports = [ ../../modules ];
      environment.systemPackages = [ pkgs.lcov ];
    };

    testScript = ''
      machine.succeed("lcov --capture --directory . --output-file coverage.info")
      machine.succeed("genhtml coverage.info --output-directory coverage")
    '';
  };
in coverage
```

## Continuous Integration

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: cachix/install-nix-action@v12
      - run: nix flake check
```

## Writing New Tests

1. Create test file in appropriate directory
2. Follow existing test patterns
3. Include both positive and negative tests
4. Add performance considerations
5. Document test purpose and requirements

## Test Documentation

Each test file should include:
- Purpose of tests
- Requirements
- Expected outcomes
- Any special setup needed

================
File: docs/troubleshooting.md
================
# Troubleshooting Guide

This guide helps you resolve common issues when using Johnny-Mnemonix.

## Common Issues

### Configuration Errors

#### Invalid Area ID Format
```
error: Area ID '1019' must be in format 'XX-YY' (e.g., '10-19')
```

**Solution:**
- Ensure area IDs use the format `XX-YY`
- Example: `"10-19"` not `"1019"`
```nix
areas = {
  "10-19" = {  # Correct
    name = "Personal";
  };
};
```

#### Invalid Category ID
```
error: Category ID '1' must be two digits (e.g., '11')
```

**Solution:**
- Use two-digit category IDs
- Example: `"11"` not `"1"`
```nix
categories = {
  "11" = {  # Correct
    name = "Finance";
  };
};
```

#### Invalid Item ID
```
error: Item ID '11.1' must be in format 'XX.YY' (e.g., '11.01')
```

**Solution:**
- Use format `XX.YY` for item IDs
- Example: `"11.01"` not `"11.1"`
```nix
items = {
  "11.01" = "Budget";  # Correct
};
```

### Directory Issues

#### Directories Not Created
**Symptoms:**
- Structure defined but directories missing
- No error messages

**Solutions:**
1. Verify module is enabled:
```nix
johnny-mnemonix.enable = true;
```

2. Check permissions:
```bash
ls -la ~/Documents
```

3. Run home-manager switch with verbose output:
```bash
home-manager switch -v
```

#### Permission Denied
**Symptoms:**
- Error creating directories
- Permission errors in home-manager output

**Solutions:**
1. Check directory ownership:
```bash
ls -la ~/Documents
```

2. Fix permissions:
```bash
chmod 755 ~/Documents
```

3. Verify user has write access to baseDir

### Integration Issues

#### Shell Alias Not Working
**Symptoms:**
- `jd` command not found
- Cannot navigate to document directory

**Solutions:**
1. Verify shell configuration:
```bash
echo $SHELL
```

2. Reload shell configuration:
```bash
# For bash
source ~/.bashrc

# For zsh
source ~/.zshrc
```

3. Check alias definition:
```bash
alias | grep jd
```

## Validation Errors

### Area Validation
```
error: The option `johnny-mnemonix.areas."invalid-id"' in ... is not of type `string matching pattern "^[0-9]{2}-[0-9]{2}$"'
```

**Solution:**
- Use correct area ID format
- Check for typos
- Verify hyphen usage

### Category Validation
```
error: The option `johnny-mnemonix.areas."10-19".categories."invalid"' in ... is not of type `string matching pattern "^[0-9]{2}$"'
```

**Solution:**
- Use two-digit category IDs
- Ensure numbers only
- Check for leading zeros

### Item Validation
```
error: The option `johnny-mnemonix.areas."10-19".categories."11".items."invalid"' in ... is not of type `string matching pattern "^[0-9]{2}[.][0-9]{2}$"'
```

**Solution:**
- Use correct item ID format
- Check decimal point placement
- Verify all digits present

## Best Practices

### Preventing Issues
1. **Use Version Control**
   - Track configuration changes
   - Roll back problematic changes
   - Share configurations safely

2. **Test Changes**
   - Use `home-manager build` before switching
   - Check configuration syntax
   - Verify directory structure

3. **Maintain Backups**
   - Backup important documents
   - Document directory structure
   - Keep configuration backups

### Debugging Steps
1. **Enable Verbose Output**
```bash
home-manager switch -v
```

2. **Check Logs**
```bash
journalctl -xe
```

3. **Verify Configuration**
```bash
home-manager check
```

## Getting Help

1. **Documentation**
   - Read the configuration guide
   - Check example configurations
   - Review troubleshooting steps

2. **Issue Reporting**
   - Provide configuration snippet
   - Include error messages
   - Describe expected behavior

3. **Community Support**
   - Use GitHub issues
   - Follow contribution guidelines
   - Be specific about problems

================
File: examples/flake.nix
================
{
  description = "Full Johnny Mnemonix configuration example";

  inputs = {
    nixpkgs.url = "github:nixpkgs/nixpkgs/nixos-unstable";
    home-manager.url = "github:nix-community/home-manager";
    johnny-mnemonix.url = "path:../../";
  };

  outputs = {
    self,
    nixpkgs,
    home-manager,
    johnny-mnemonix,
  }: {
    homeConfigurations."example" = home-manager.lib.homeManagerConfiguration {
      pkgs = nixpkgs.legacyPackages.x86_64-linux;
      modules = [
        johnny-mnemonix.homeManagerModules.default
        {
          home.username = "user1";
          home.homeDirectory = "/home/user1";
          home.stateVersion = "24.11";

          johnny-mnemonix = {
            enable = true;
            baseDir = "/home/example/Documents";

            areas = {
              "10-19" = {
                name = "Personal";
                categories = {
                  "11" = {
                    name = "Finance";
                    items = {
                      "11.01" = "Budget";
                      "11.02" = "Investments";
                      "11.03" = "Tax Records";
                      "11.04" = "Insurance";
                    };
                  };
                  "12" = {
                    name = "Health";
                    items = {
                      "12.01" = "Medical Records";
                      "12.02" = "Fitness Plans";
                      "12.03" = "Diet Plans";
                    };
                  };
                };
              };

              "20-29" = {
                name = "Work";
                categories = {
                  "21" = {
                    name = "Projects";
                    items = {
                      "21.01" = "Current Project";
                      "21.02" = "Project Archive";
                      "21.03" = "Project Templates";
                    };
                  };
                  "22" = {
                    name = "Admin";
                    items = {
                      "22.01" = "Contracts";
                      "22.02" = "Timesheets";
                      "22.03" = "Expenses";
                    };
                  };
                };
              };

              "30-39" = {
                name = "Archive";
                categories = {
                  "31" = {
                    name = "Old Projects";
                    items = {
                      "31.01" = "2023 Projects";
                      "31.02" = "2022 Projects";
                    };
                  };
                };
              };
            };
          };
        }
      ];
    };
  };
}

================
File: lib/default.nix
================
{nixpkgs}: {
  schema = import ./schema.nix {inherit nixpkgs;};
  utils = import ./utils.nix {inherit nixpkgs;};
}

================
File: lib/schema.nix
================
{nixpkgs}: let
  inherit (nixpkgs.lib) types;

  validate = {
    areaId = id: name: let
      pattern = "^[0-9]{2}-[0-9]{2}$";
      isValid = builtins.match pattern id != null;
      errorMsg = "Area ID '${id}' must be in format 'XX-YY' (e.g., '10-19')";
    in
      if isValid
      then true
      else throw errorMsg;

    categoryId = id: name: let
      pattern = "^[0-9]{2}$";
      isValid = builtins.match pattern id != null;
      errorMsg = "Category ID '${id}' must be two digits (e.g., '11')";
    in
      if isValid
      then true
      else throw errorMsg;

    itemId = id: name: let
      pattern = "^[0-9]{2}[.][0-9]{2}$";
      isValid = builtins.match pattern id != null;
      errorMsg = "Item ID '${id}' must be in format 'XX.YY' (e.g., '11.01')";
    in
      if isValid
      then true
      else throw errorMsg;
  };
in {
  inherit validate;

  # Core type definitions
  types = {
    # Area ID must be in format XX-YY (e.g., 10-19)
    areaId = types.strMatching "^[0-9]{2}-[0-9]{2}$";

    # Category ID must be two digits (e.g., 11)
    categoryId = types.strMatching "^[0-9]{2}$";

    # Item ID must be in format XX.YY (e.g., 11.01)
    itemId = types.strMatching "^[0-9]{2}[.][0-9]{2}$";

    # Area must be a submodule with name and categories
    area = types.submodule {
      options = {
        name = types.str;
        categories = types.attrsOf types.category;
      };
    };

    # Category must be a submodule with name and items
    category = types.submodule {
      options = {
        name = types.str;
        items = types.attrsOf types.str;
      };
    };
  };

  # Constructor functions
  mkArea = {
    id,
    name,
    categories ? {},
  }:
    assert validate.areaId id name; {
      inherit name categories;
    };

  mkCategory = {
    id,
    name,
    items ? {},
  }:
    assert validate.categoryId id name; {
      inherit name items;
    };

  mkItem = {
    id,
    name,
  }:
    assert validate.itemId id name; {
      inherit name;
    };
}

================
File: lib/utils.nix
================
{nixpkgs}: let
  inherit (nixpkgs.lib) strings;

  error.handleError = message: code: ''
    echo "Error: ${message}" >&2
    return ${toString code}
  '';
in {
  error = {
    inherit (error) handleError;

    validatePath = path: ''
      if [[ ! -d "${path}" ]]; then
        ${error.handleError "Directory does not exist: ${path}" 1}
      fi
    '';
  };

  # Update path utilities with better error handling
  path = {
    # Make a path safe for shell usage with validation
    makeShellSafe = path: let
      sanitized = strings.escapeShellArg path;
    in ''
      if [[ "${sanitized}" =~ [[:space:]] ]]; then
        ${error.handleError "Path contains spaces: ${path}" 1}
      fi
      echo "${sanitized}"
    '';

    # Create full path for an item
    makeItemPath = {
      baseDir,
      areaId,
      areaName,
      categoryId,
      categoryName,
      itemId,
      itemName,
    }: "${baseDir}/${areaId} ${areaName}/${categoryId} ${categoryName}/${itemId} ${itemName}";

    # Create path for an area
    makeAreaPath = {
      baseDir,
      areaId,
      areaName,
    }: "${baseDir}/${areaId} ${areaName}";

    # Create path for a category
    makeCategoryPath = {
      baseDir,
      areaId,
      areaName,
      categoryId,
      categoryName,
    }: "${baseDir}/${areaId} ${areaName}/${categoryId} ${categoryName}";

    # Create cd command with proper escaping
    cdCommand = path: ''
      cd ${strings.escapeShellArg path}
    '';
  };

  # String manipulation utilities
  string = {
    # Sanitize a name for filesystem use
    sanitizeName = name:
      strings.sanitizeDerivationName name;

    # Format an area ID (ensure XX-YY format)
    formatAreaId = id: let
      parts = strings.splitString "-" id;
      pad = s:
        if (strings.stringLength s) == 1
        then "0${s}"
        else s;
    in "${pad (builtins.elemAt parts 0)}-${pad (builtins.elemAt parts 1)}";

    # Format a category ID (ensure XX format)
    formatCategoryId = id:
      if (strings.stringLength id) == 1
      then "0${id}"
      else id;

    # Format an item ID (ensure XX.YY format)
    formatItemId = id: let
      parts = strings.splitString "." id;
      padFirst = s:
        if (strings.stringLength s) == 1
        then "0${s}"
        else s;
      padSecond = s:
        if (strings.stringLength s) == 1
        then "0${s}"
        else s;
    in "${padFirst (builtins.elemAt parts 0)}.${padSecond (builtins.elemAt parts 1)}";
  };
}

================
File: modules/core/activation.nix
================
{
  config,
  lib,
  pkgs,
  ...
}: let
  cfg = config.johnny-mnemonix;
in {
  createDirectories = {
    data = let
      mkAreaDir = areaId: area: "${cfg.baseDir}/${areaId} ${area.name}";
      mkCategoryDir = areaId: area: catId: cat: "${mkAreaDir areaId area}/${catId} ${cat.name}";
      mkItemDir = areaId: area: catId: cat: itemId: name: "${mkCategoryDir areaId area catId cat}/${itemId} ${name}";
    in ''
      # Create base directory
      mkdir -p "${cfg.baseDir}"
      chmod 750 "${cfg.baseDir}"

      # Create area directories
      ${builtins.concatStringsSep "\n" (lib.attrValues (lib.mapAttrs (areaId: area: ''
          mkdir -p "${mkAreaDir areaId area}"
          chmod 750 "${mkAreaDir areaId area}"
        '')
        cfg.areas))}

      # Create category directories
      ${builtins.concatStringsSep "\n" (lib.concatLists (lib.attrValues (lib.mapAttrs (
          areaId: area:
            lib.attrValues (lib.mapAttrs (catId: cat: ''
                mkdir -p "${mkCategoryDir areaId area catId cat}"
                chmod 750 "${mkCategoryDir areaId area catId cat}"
              '')
              area.categories)
        )
        cfg.areas)))}

      # Create item directories
      ${builtins.concatStringsSep "\n" (lib.concatLists (lib.attrValues (lib.mapAttrs (
          areaId: area:
            lib.concatLists (lib.attrValues (lib.mapAttrs (
                catId: cat:
                  lib.attrValues (lib.mapAttrs (itemId: name: ''
                      mkdir -p "${mkItemDir areaId area catId cat itemId name}"
                      chmod 750 "${mkItemDir areaId area catId cat itemId name}"
                    '')
                    cat.items)
              )
              area.categories))
        )
        cfg.areas)))}
    '';
    type = "data";
    after = ["writeBoundary"];
  };
}

================
File: modules/core/default.nix
================
{
  config,
  lib,
  pkgs,
  ...
}:
with lib; let
  cfg = config.johnny-mnemonix;

  # Import utility functions
  utils = import ../../lib/utils.nix {nixpkgs = pkgs;};

  # Helper function to create directory commands
  mkDirCmd = path: ''
    $DRY_RUN_CMD mkdir $VERBOSE_ARG -p "${path}"
    $DRY_RUN_CMD chmod $VERBOSE_ARG 750 "${path}"
  '';

  # Helper functions for directory creation
  mkAreaDirs = mapAttrsToList (areaId: area:
    mkDirCmd (utils.path.makeAreaPath {
      baseDir = cfg.baseDir;
      areaId = areaId;
      areaName = area.name;
    }))
  cfg.areas;

  mkCategoryDirs = mapAttrsToList (areaId: area:
    mapAttrsToList (catId: cat:
      mkDirCmd (utils.path.makeCategoryPath {
        baseDir = cfg.baseDir;
        areaId = areaId;
        areaName = area.name;
        categoryId = catId;
        categoryName = cat.name;
      }))
    area.categories)
  cfg.areas;

  mkItemDirs = mapAttrsToList (areaId: area:
    mapAttrsToList (catId: cat:
      mapAttrsToList (itemId: name:
        mkDirCmd (utils.path.makeItemPath {
          baseDir = cfg.baseDir;
          areaId = areaId;
          areaName = area.name;
          categoryId = catId;
          categoryName = cat.name;
          itemId = itemId;
          itemName = name;
        }))
      cat.items)
    area.categories)
  cfg.areas;
in {
  config = mkIf cfg.enable {
    home.activation.createJohnnyMnemonixStructure = lib.hm.dag.entryAfter ["writeBoundary"] ''
      # Create base directory
      ${mkDirCmd cfg.baseDir}

      # Create area directories
      ${concatStringsSep "\n" mkAreaDirs}

      # Create category directories
      ${concatStringsSep "\n" (concatLists mkCategoryDirs)}

      # Create item directories
      ${concatStringsSep "\n" (concatLists (concatLists mkItemDirs))}
    '';
  };
}

================
File: modules/core/validation.nix
================
{
  config,
  lib,
  ...
}:
with lib; let
  # Enhanced error formatting
  formatError = context: message: details: ''
    Error in ${context}:
    ${message}
    Details: ${details}
  '';

  # Robust integer parsing
  toSafeInt = str: let
    result = builtins.tryEval (builtins.fromJSON str);
  in
    if result.success && builtins.match "^[0-9]+$" str != null
    then result.value
    else null;

  # Validation rules with more robust checks
  rules = {
    area = {
      id = {
        pattern = "^[0-9]{2}-[0-9]{2}$";
        message = "Area ID must be in format XX-YY (e.g., 10-19)";
        validate = value: builtins.match rules.area.id.pattern value != null;
      };
      name = {
        pattern = "^[A-Za-z0-9][A-Za-z0-9 _-]*$";
        message = "Area name must start with alphanumeric and contain only letters, numbers, spaces, underscores, or hyphens";
        validate = value: builtins.match rules.area.name.pattern value != null;
      };
      range = {
        message = "Area range must be valid (e.g., 10-19 contains categories 10-19)";
        validate = value: let
          parts = builtins.split "-" value;
          start = toSafeInt (elemAt parts 0);
          end = toSafeInt (elemAt parts 1);
        in
          if start == null || end == null
          then false
          else start <= end && (end - start) <= 9;
      };
    };

    category = {
      id = {
        pattern = "^[0-9]{2}$";
        message = "Category ID must be two digits (e.g., 11)";
        validate = value: builtins.match rules.category.id.pattern value != null;
      };
      name = {
        pattern = "^[A-Za-z0-9][A-Za-z0-9 _-]*$";
        message = "Category name must start with alphanumeric and contain only letters, numbers, spaces, underscores, or hyphens";
        validate = value: builtins.match rules.category.name.pattern value != null;
      };
      inRange = {
        areaId,
        categoryId,
      }: {
        message = "Category ID must be within area range";
        validate = value: let
          parts = builtins.split "-" areaId;
          areaStart = toSafeInt (elemAt parts 0);
          areaEnd = toSafeInt (elemAt parts 1);
          catNum = toSafeInt value;
        in
          areaStart
          != null
          && areaEnd != null
          && catNum != null
          && catNum >= areaStart
          && catNum <= areaEnd;
      };
    };

    item = {
      id = {
        pattern = "^[0-9]{2}[.][0-9]{2}$";
        message = "Item ID must be in format XX.YY (e.g., 11.01)";
        validate = value: builtins.match rules.item.id.pattern value != null;
      };
      name = {
        pattern = "^[A-Za-z0-9][A-Za-z0-9 _-]*$";
        message = "Item name must start with alphanumeric and contain only letters, numbers, spaces, underscores, or hyphens";
        validate = value: builtins.match rules.item.name.pattern value != null;
      };
      matchesCategory = {
        itemId,
        categoryId,
      }: {
        message = "Item ID must match its category ID (e.g., 11.01 belongs to category 11)";
        validate = value: let
          itemPrefix = substring 0 2 value;
        in
          itemPrefix == categoryId;
      };
    };
  };

  # Validation functions with improved error collection
  validateStructure = structure: let
    validateArea = areaId: area: let
      areaErrors =
        (
          if !rules.area.id.validate areaId
          then [(formatError "Area ${areaId}" rules.area.id.message "Got '${areaId}', expected format: XX-YY")]
          else []
        )
        ++ (
          if !rules.area.name.validate area.name
          then [(formatError "Area ${areaId}" rules.area.name.message "Got '${area.name}', expected format: [A-Za-z0-9][A-Za-z0-9 _-]*")]
          else []
        )
        ++ (
          if !rules.area.range.validate areaId
          then [(formatError "Area ${areaId}" rules.area.range.message "Got '${areaId}', expected format: XX-YY")]
          else []
        );
    in
      areaErrors ++ (validateCategories areaId area.categories);

    validateCategories = areaId: categories:
      if categories == null
      then []
      else
        concatLists (mapAttrsToList (
            categoryId: category:
              (
                if !rules.category.id.validate categoryId
                then [(formatError "Category ${categoryId}" rules.category.id.message "Got '${categoryId}', expected format: XX")]
                else []
              )
              ++ (
                if !rules.category.name.validate category.name
                then [(formatError "Category ${categoryId}" rules.category.name.message "Got '${category.name}', expected format: [A-Za-z0-9][A-Za-z0-9 _-]*")]
                else []
              )
              ++ (
                if !rules.category.inRange {inherit areaId categoryId;}.validate categoryId
                then [(formatError "Category ${categoryId}" rules.category.inRange.message "Got '${categoryId}', expected to be within area range")]
                else []
              )
              ++ (validateItems categoryId category.items)
          )
          categories);

    validateItems = categoryId: items:
      if items == null
      then []
      else
        concatLists (mapAttrsToList (
            itemId: itemName:
              (
                if !rules.item.id.validate itemId
                then [(formatError "Item ${itemId}" rules.item.id.message "Got '${itemId}', expected format: XX.YY")]
                else []
              )
              ++ (
                if !rules.item.name.validate itemName
                then [(formatError "Item ${itemId}" rules.item.name.message "Got '${itemName}', expected format: [A-Za-z0-9][A-Za-z0-9 _-]*")]
                else []
              )
              ++ (
                if !rules.item.matchesCategory {inherit itemId categoryId;}.validate itemId
                then [(formatError "Item ${itemId}" rules.item.matchesCategory.message "Got '${itemId}', expected to match category ID")]
                else []
              )
          )
          items);

    allErrors = concatLists (mapAttrsToList validateArea structure);
  in {
    valid = allErrors == [];
    errors = allErrors;
  };
in {
  # Export validation functions
  inherit validateStructure rules;

  # Add validation options to the module
  options.johnny-mnemonix = {
    validation = {
      strict = mkOption {
        type = types.bool;
        default = true;
        description = "Whether to fail on validation errors";
      };

      customRules = mkOption {
        type = types.attrsOf (types.submodule {
          options = {
            pattern = mkOption {
              type = types.str;
              description = "Regex pattern for validation";
            };
            message = mkOption {
              type = types.str;
              description = "Error message";
            };
            validate = mkOption {
              type = types.functionTo types.bool;
              description = "Validation function";
            };
          };
        });
        default = {};
        description = "Custom validation rules";
      };
    };
  };

  # Add validation to the configuration
  config = mkIf config.johnny-mnemonix.enable {
    assertions = let
      validationResult = validateStructure config.johnny-mnemonix.areas;
    in [
      {
        assertion = !config.johnny-mnemonix.validation.strict || validationResult.valid;
        message = ''
          Johnny-Mnemonix configuration validation failed:
          ${concatStringsSep "\n" validationResult.errors}
        '';
      }
    ];
  };
}

================
File: modules/core.nix
================
{
  config,
  lib,
  # pkgs,
  ...
}:
with lib; let
  cfg = config.mnemonic;
in {
  imports = [
    ./plugins
  ];

  options.mnemonic = {
    # Core options will go here
  };

  config = mkIf cfg.enable {
    # Core configuration will go here
  };
}

================
File: modules/default.nix
================
{
  config,
  lib,
  pkgs,
  ...
}:
with lib; let
  cfg = config.johnny-mnemonix;
in {
  imports = [
    ./core/default.nix
  ];

  options.johnny-mnemonix = {
    enable = mkEnableOption "Johnny Mnemonix document management";

    baseDir = mkOption {
      type = types.addCheck types.path (
        x:
          builtins.substring 0 1 (toString x) == "/"
      );
      apply = toString;
      default = "${config.home.homeDirectory}/Documents";
      description = "Base directory for document structure";
    };

    areas = mkOption {
      type = types.attrs;
      default = {};
      description = "Document areas configuration";
    };

    validation = {
      strict = mkOption {
        type = types.bool;
        default = false;
        description = "Enable strict validation of the document structure";
      };
    };
  };

  config = mkIf cfg.enable {
    programs.bash.shellAliases = {
      "jd" = "cd ${cfg.baseDir}";
    };
    programs.zsh.shellAliases = {
      "jd" = "cd ${cfg.baseDir}";
    };
    programs.fish.shellAliases = {
      "jd" = "cd ${cfg.baseDir}";
    };
  };

  meta = {
    maintainers = ["lessuseless"];
    doc = ./johnny-mnemonix.md;
  };
}

================
File: tests/performance/structure.nix
================
{pkgs ? import <nixpkgs> {}}: let
  # Improved structure generation with chunking
  generateLargeStructure = count: let
    # Generate in chunks of 100 to avoid memory issues
    chunkSize = 100;
    chunks = builtins.ceil (count / chunkSize);

    # Generate a single chunk
    generateChunk = offset: size:
      builtins.listToAttrs (builtins.genList (n: {
          name = "area-${toString (offset + n)}";
          value = {
            categories = generateCategories (offset + n) (size / 10);
          };
        })
        size);

    # Generate categories with limited items
    generateCategories = areaNum: size:
      builtins.listToAttrs (builtins.genList (n: {
          name = "cat-${toString n}";
          value = {
            items = generateItems n 5; # Limit items per category
          };
        })
        size);

    # Generate a reasonable number of items
    generateItems = catNum: size:
      builtins.listToAttrs (builtins.genList (n: {
          name = "item-${toString n}";
          value = "Test Item ${toString n}";
        })
        size);

    # Combine chunks
    combineChunks = chunks: offset:
      if chunks == 0
      then {}
      else
        generateChunk (offset * chunkSize) (
          if chunks == 1
          then count - (offset * chunkSize)
          else chunkSize
        )
        // combineChunks (chunks - 1) (offset + 1);
  in
    combineChunks chunks 0;
in {
  name = "johnny-mnemonix-performance";

  nodes.machine = {
    config,
    pkgs,
    ...
  }: {
    imports = [../../modules];

    johnny-mnemonix = {
      enable = true;
      areas = generateLargeStructure 1000;
    };
  };

  # Improved test script with better metrics
  testScript = ''
    import time
    import resource

    def measure_performance():
        start_time = time.time()
        start_memory = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

        machine.wait_for_unit("home-manager-test.service")

        end_time = time.time()
        end_memory = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

        duration = end_time - start_time
        memory_used = (end_memory - start_memory) / 1024  # Convert to MB

        print(f"Performance Metrics:")
        print(f"Time taken: {duration:.2f}s")
        print(f"Memory used: {memory_used:.2f}MB")

        # Fail if performance thresholds are exceeded
        assert duration < 5.0, f"Time threshold exceeded: {duration:.2f}s > 5.0s"
        assert memory_used < 512, f"Memory threshold exceeded: {memory_used:.2f}MB > 512MB"

    measure_performance()
  '';
}

================
File: CHANGELOG.md
================
# Changelog

All notable changes to Johnny-Mnemonix will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial project structure
- Core module functionality
- Directory structure creation
- Shell integration (bash, zsh, fish)
- Validation for Johnny Decimal structure
- Documentation and examples

### Changed
- None

### Deprecated
- None

### Removed
- None

### Fixed
- None

### Security
- None

## [0.1.0] - YYYY-MM-DD
- Initial release

[Unreleased]: https://github.com/lessuselesss/johnny-mnemonix/compare/v0.1.0...HEAD
[0.1.0]: https://github.com/lessuselesss/johnny-mnemonix/releases/tag/v0.1.0

================
File: CONTRIBUTING.md
================
# Contributing to Johnny-Mnemonix

Thank you for your interest in contributing to Johnny-Mnemonix! This document provides guidelines and information for contributors.

## Code of Conduct

Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.

## Getting Started

1. **Fork the Repository**
   ```bash
   git clone https://github.com/lessuselesss/johnny-mnemonix.git
   cd johnny-mnemonix
   ```

2. **Set Up Development Environment**
   ```bash
   # Enter development shell
   nix develop
   ```

3. **Make Your Changes**
   - Write clear, concise commit messages
   - Follow the existing code style
   - Add tests for new features
   - Update documentation as needed

## Development Guidelines

### Code Style

- Follow the Nixpkgs coding style
- Use meaningful variable names
- Add comments for complex logic
- Keep functions focused and small

### Commit Messages

Format:
```
type(scope): description

[optional body]
[optional footer]
```

Types:
- feat: New feature
- fix: Bug fix
- docs: Documentation changes
- style: Formatting changes
- refactor: Code restructuring
- test: Adding tests
- chore: Maintenance tasks

### Testing

1. **Run Tests**
   ```bash
   nix flake check
   ```

2. **Test Configuration**
   ```bash
   home-manager build -I johnny-mnemonix=.
   ```

### Documentation

- Update README.md for user-facing changes
- Add/update documentation in docs/
- Include examples for new features
- Document breaking changes

## Pull Request Process

1. **Create Feature Branch**
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. **Make Changes**
   - Follow development guidelines
   - Keep changes focused
   - Test thoroughly

3. **Submit Pull Request**
   - Describe changes clearly
   - Reference related issues
   - Update documentation
   - Add tests if needed

4. **Review Process**
   - Address review comments
   - Keep discussion focused
   - Be patient and respectful

## Release Process

1. **Version Bumping**
   - Update version in flake.nix
   - Update CHANGELOG.md
   - Create release notes

2. **Testing**
   - Verify all tests pass
   - Check documentation
   - Test installation process

3. **Release**
   - Tag release in git
   - Update documentation
   - Announce changes

## Getting Help

- Open an issue for questions
- Join community discussions
- Read existing documentation

Thank you for contributing to Johnny-Mnemonix!

================
File: default.nix
================
{
  config,
  lib,
  ...
}:
with lib; let
  cfg = config.mnemonic;

  # XDG Base Directory specification
  xdgBase = {
    data = "${config.xdg.dataHome}/johnny-mnemonix";
    config = "${config.xdg.configHome}/johnny-mnemonix";
    cache = "${config.xdg.cacheHome}/johnny-mnemonix";
    state = "${config.xdg.stateHome}/johnny-mnemonix";
  };
in {
  options.mnemonic = {
    enable = mkEnableOption "Johnny Mnemonic document management";

    baseDir = mkOption {
      type = types.str;
      default = "${config.home.homeDirectory}/Documents";
      description = "Base directory for document structure";
    };

    xdgCompliance = mkOption {
      type = types.bool;
      default = true;
      description = "Enforce XDG Base Directory compliance";
    };
  };

  config = mkIf cfg.enable {
    # Store configuration
    xdg.configFile."johnny-mnemonix/config.toml".text = ''
      base_dir = "${cfg.baseDir}"
      xdg_compliance = ${
        if cfg.xdgCompliance
        then "true"
        else "false"
      }
    '';

    # Store templates for new directory structures
    xdg.dataFile = {
      # Basic template with common areas
      "johnny-mnemonix/templates/basic.toml".text = ''
        [[area]]
        id = "10-19"
        name = "Personal"

        [[category]]
        id = "11"
        name = "Finance"
      '';

      # Template for work-related structure
      "johnny-mnemonix/templates/work.toml".text = ''
        [[area]]
        id = "20-29"
        name = "Work"

        [[category]]
        id = "21"
        name = "Projects"
      '';
    };

    # Create required directories
    home.activation.createJohnnyMnemonixDirs = lib.hm.dag.entryAfter ["writeBoundary"] ''
      # Cache directories
      $DRY_RUN_CMD mkdir -p "${xdgBase.cache}/search"  # For search indexes
      $DRY_RUN_CMD mkdir -p "${xdgBase.cache}/temp"    # For temporary operations

      # State directories
      $DRY_RUN_CMD mkdir -p "${xdgBase.state}/history" # Command history
      $DRY_RUN_CMD mkdir -p "${xdgBase.state}/recent"  # Recently accessed paths

      # Data directories
      $DRY_RUN_CMD mkdir -p "${xdgBase.data}/templates"  # User-modified templates
      $DRY_RUN_CMD mkdir -p "${xdgBase.data}/metadata"   # Document metadata
    '';

    # Add shell integration for XDG paths
    programs.bash.initExtra = ''
      export JOHNNY_MNEMONIX_CONFIG="${xdgBase.config}"
      export JOHNNY_MNEMONIX_CACHE="${xdgBase.cache}"
      export JOHNNY_MNEMONIX_DATA="${xdgBase.data}"
      export JOHNNY_MNEMONIX_STATE="${xdgBase.state}"
    '';

    programs.zsh.initExtra = ''
      export JOHNNY_MNEMONIX_CONFIG="${xdgBase.config}"
      export JOHNNY_MNEMONIX_CACHE="${xdgBase.cache}"
      export JOHNNY_MNEMONIX_DATA="${xdgBase.data}"
      export JOHNNY_MNEMONIX_STATE="${xdgBase.state}"
    '';
  };
}

================
File: flake.lock
================
{
  "nodes": {
    "home-manager": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      },
      "locked": {
        "lastModified": 1733389730,
        "narHash": "sha256-KZMu4ddMll5khS0rYkJsVD0hVqjMNHlhTM3PCQar0Ag=",
        "owner": "nix-community",
        "repo": "home-manager",
        "rev": "65912bc6841cf420eb8c0a20e03df7cbbff5963f",
        "type": "github"
      },
      "original": {
        "owner": "nix-community",
        "repo": "home-manager",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1733212471,
        "narHash": "sha256-M1+uCoV5igihRfcUKrr1riygbe73/dzNnzPsmaLCmpo=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "55d15ad12a74eb7d4646254e13638ad0c4128776",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "nixpkgs_2": {
      "locked": {
        "lastModified": 1733212471,
        "narHash": "sha256-M1+uCoV5igihRfcUKrr1riygbe73/dzNnzPsmaLCmpo=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "55d15ad12a74eb7d4646254e13638ad0c4128776",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "home-manager": "home-manager",
        "nixpkgs": "nixpkgs_2"
      }
    }
  },
  "root": "root",
  "version": 7
}

================
File: flake.nix
================
{
  description = "Flattened Johnny Mnemonix configuration example";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    home-manager.url = "github:nix-community/home-manager";
  };

  outputs = {
    self,
    nixpkgs,
    home-manager,
  }: let
    # Core validation functions
    validateStructure = structure: let
      rules = {
        area = {
          id = {
            pattern = "^[0-9]{2}-[0-9]{2}$";
            message = "Area ID must be in format XX-YY (e.g., 10-19)";
            validate = value: builtins.match rules.area.id.pattern value != null;
          };
          name = {
            pattern = "^[A-Za-z0-9][A-Za-z0-9 _-]*$";
            message = "Area name must start with alphanumeric and contain only letters, numbers, spaces, underscores, or hyphens";
            validate = value: builtins.match rules.area.name.pattern value != null;
          };
        };
        category = {
          id = {
            pattern = "^[0-9]{2}$";
            message = "Category ID must be two digits (e.g., 11)";
            validate = value: builtins.match rules.category.id.pattern value != null;
          };
          name = {
            pattern = "^[A-Za-z0-9][A-Za-z0-9 _-]*$";
            message = "Category name must start with alphanumeric";
            validate = value: builtins.match rules.category.name.pattern value != null;
          };
        };
        item = {
          id = {
            pattern = "^[0-9]{2}[.][0-9]{2}$";
            message = "Item ID must be in format XX.YY (e.g., 11.01)";
            validate = value: builtins.match rules.item.id.pattern value != null;
          };
          name = {
            pattern = "^[A-Za-z0-9][A-Za-z0-9 _-]*$";
            message = "Item name must start with alphanumeric";
            validate = value: builtins.match rules.item.name.pattern value != null;
          };
        };
      };

      validateArea = areaId: area:
        if !rules.area.id.validate areaId
        then false
        else if !rules.area.name.validate area.name
        then false
        else true;

      validateCategory = categoryId: category:
        if !rules.category.id.validate categoryId
        then false
        else if !rules.category.name.validate category.name
        then false
        else true;

      validateItem = itemId: itemName:
        if !rules.item.id.validate itemId
        then false
        else if !rules.item.name.validate itemName
        then false
        else true;

      # Validate entire structure
      isValid = builtins.all (
        areaId: let
          area = structure.${areaId};
        in
          validateArea areaId area
          && builtins.all (
            catId: let
              category = area.categories.${catId};
            in
              validateCategory catId category
              && builtins.all (
                itemId:
                  validateItem itemId category.items.${itemId}
              ) (builtins.attrNames category.items)
          ) (builtins.attrNames area.categories)
      ) (builtins.attrNames structure);
    in {
      valid = isValid;
      rules = rules;
    };

    # Directory creation function
    mkDirs = baseDir: areas: let
      mkAreaDir = areaId: area: "${baseDir}/${areaId} ${area.name}";
      mkCategoryDir = areaId: area: catId: cat: "${mkAreaDir areaId area}/${catId} ${cat.name}";
      mkItemDir = areaId: area: catId: cat: itemId: name: "${mkCategoryDir areaId area catId cat}/${itemId} ${name}";
    in ''
      # Create base directory
      mkdir -p "${baseDir}"
      chmod 750 "${baseDir}"

      # Create area directories
      ${builtins.concatStringsSep "\n" (builtins.attrValues (builtins.mapAttrs (areaId: area: ''
          mkdir -p "${mkAreaDir areaId area}"
          chmod 750 "${mkAreaDir areaId area}"
        '')
        areas))}

      # Create category directories
      ${builtins.concatStringsSep "\n" (builtins.concatLists (builtins.attrValues (builtins.mapAttrs (
          areaId: area:
            builtins.attrValues (builtins.mapAttrs (catId: cat: ''
                mkdir -p "${mkCategoryDir areaId area catId cat}"
                chmod 750 "${mkCategoryDir areaId area catId cat}"
              '')
              area.categories)
        )
        areas)))}

      # Create item directories
      ${builtins.concatStringsSep "\n" (builtins.concatLists (builtins.attrValues (builtins.mapAttrs (
          areaId: area:
            builtins.concatLists (builtins.attrValues (builtins.mapAttrs (
                catId: cat:
                  builtins.attrValues (builtins.mapAttrs (itemId: name: ''
                      mkdir -p "${mkItemDir areaId area catId cat itemId name}"
                      chmod 750 "${mkItemDir areaId area catId cat itemId name}"
                    '')
                    cat.items)
              )
              area.categories))
        )
        areas)))}
    '';
  in {
    homeConfigurations."example" = home-manager.lib.homeManagerConfiguration {
      pkgs = nixpkgs.legacyPackages.aarch64-darwin;
      modules = [
        ./modules/default.nix
        {
          home.username = "lessuseless";
          home.homeDirectory = "/Users/lessuseless";
          home.stateVersion = "24.11";

          johnny-mnemonix = {
            enable = true;
            baseDir = "/Users/lessuseless/Documents";
            validation.strict = true;

            # Your existing areas configuration
            areas = {
              "10-19" = {
                name = "Personal";
                categories = {
                  "11" = {
                    name = "Finance";
                    items = {
                      "11.01" = "Budget";
                      "11.02" = "Investments";
                      "11.03" = "Tax Records";
                    };
                  };
                  # ... rest of your existing configuration ...
                };
              };
            };
          };

          # Create directories on activation
          home.activation.createJohnnyMnemonixStructure = {
            config,
            lib,
          }: let
            validation = validateStructure config.johnny-mnemonix.areas;
          in
            lib.hm.dag.entryAfter ["writeBoundary"] (
              if !validation.valid && config.johnny-mnemonix.validation.strict
              then throw "Invalid Johnny Mnemonix structure"
              else mkDirs config.johnny-mnemonix.baseDir config.johnny-mnemonix.areas
            );

          # Shell integration
          programs = {
            bash.shellAliases.jd = "cd /Users/lessuseless/Documents";
            zsh.shellAliases.jd = "cd /Users/lessuseless/Documents";
            fish.shellAliases.jd = "cd /Users/lessuseless/Documents";
          };
        }
      ];
    };
  };
}

================
File: README.md
================
# Johnny-Mnemonix

> Declarative document management using the Johnny Decimal system, powered by Nix

Johnny-Mnemonix is a Home Manager module that brings the power of declarative configuration to your document management, implementing the [Johnny Decimal](https://johnnydecimal.com/) system in a Nix-native way. It provides a structured, reproducible approach to organizing your `$HOME/Documents` directory (aka your `$HOMEOFFICE`).

## Features

- 🏗️ **Declarative Structure**: Define your entire document hierarchy in Nix, ensuring consistency across systems
- 📁 **Johnny Decimal Implementation**: First-class support for the [Johnny Decimal](https://johnnydecimal.com/) organizational system
- 🔄 **XDG Compliance**: Follows XDG Base Directory specifications for configuration and cache data
- 📝 **Typst Integration**: Seamless integration with [Typix](https://github.com/loqusion/typix) for deterministic document compilation
- 🔍 **Smart Search**: Quick document location using Johnny Decimal codes
- 🔄 **Version Control Ready**: Designed to work well with Git for document versioning
- 🏠 **Home Manager Native**: Integrates naturally with your existing Home Manager configuration

## Directory Structure

When enabled, Johnny-Mnemonix creates the following structure:

```
$HOMEOFFICE/ #($HOME/Documents/)
├── 10-19 Area/
│   ├── 11 Category/
│   │   ├── 11.01 ID-Name/
│   │   └── 11.02 ID-Name/
│   └── ...
└── ...
```

Each component follows the Johnny Decimal system, `analogizing a Book Case`  

`shelf` 

- **Areas**: Broad divisions (10-19, 20-29, etc.)
  
`box`

- **Categories**: Subdivisions within areas (11, 12, etc.)
  
`book`

- **IDs**: Specific locations for files (11.01, 11.02, etc.) 

## Configuration

See our [documentation](./docs/configuration.md) for detailed configuration options and examples.

## Why Johnny-Mnemonix?

The name combines "Johnny Decimal" with "Nix" and pays homage to William Gibson's "Johnny Mnemonic" - a character who stores digital data in his brain. Similarly, Johnny-Mnemonix helps you store and organize your digital life in a structured, reproducible way.

## Installation & Usage

### 1. Add to Flake Inputs
In your system's `flake.nix`, add Johnny-Mnemonix to your inputs:

```nix
{
  inputs = {
    nixpkgs.url = "github:nixpkgs/nixpkgs/nixos-unstable";
    home-manager = {
      url = "github:nix-community/home-manager";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    johnny-mnemonix.url = "github:lessuselesss/johnny-mnemonix";
  };

  outputs = { self, nixpkgs, home-manager, johnny-mnemonix }: {
    homeManagerConfigurations.${user} = home-manager.lib.homeManagerConfiguration {
      # Your existing config...
      modules = [
        johnny-mnemonix.homeManagerModules.default
        ./home.nix
      ];
    };
  };
}
```

### 2. Configure Your Document Structure
In your `home.nix` (or other Home Manager configuration file), define your document structure:

```nix
{
  johnny-mnemonix = {
    enable = true;
    # Optional: customize base directory
    baseDir = "${config.home.homeDirectory}/Documents";
    
    areas = {
      "10-19" = {
        name = "Personal";
        categories = {
          "11" = {
            name = "Finance";
            items = {
              "11.01" = "Budget";
              "11.02" = "Investments";
            };
          };
          "12" = {
            name = "Health";
            items = {
              "12.01" = "Medical Records";
              "12.02" = "Fitness Plans";
            };
          };
        };
      };
      "20-29" = {
        name = "Work";
        categories = {
          "21" = {
            name = "Projects";
            items = {
              "21.01" = "Current Project";
              "21.02" = "Project Archive";
            };
          };
        };
      };
    };
  };
}
```

### 3. Apply Configuration
Run Home Manager to create your directory structure:

```bash
home-manager switch
```

This will create a directory structure like:

```
Documents/
├── 10-19 Personal/
│   ├── 11 Finance/
│   │   ├── 11.01 Budget/
│   │   └── 11.02 Investments/
│   └── 12 Health/
│       ├── 12.01 Medical Records/
│       └── 12.02 Fitness Plans/
└── 20-29 Work/
    └── 21 Projects/
        ├── 21.01 Current Project/
        └── 21.02 Project Archive/
```

### 4. Navigate Your Structure
After installation, you can use the provided shell alias to navigate to your document root:

```bash
# Navigate to your document root
jd

# Or navigate to specific directories using standard cd commands
cd ~/Documents/10-19\ Personal/11\ Finance/11.01\ Budget
```

### Important Notes

- The directory structure is created non-destructively (won't overwrite existing directories)
- All directory names must follow the Johnny Decimal format:
  - Areas: XX-YY format (e.g., "10-19")
  - Categories: XX format (e.g., "11")
  - Items: XX.YY format (e.g., "11.01")
- The `jd` alias is available in both bash and zsh
- You can modify the structure by updating your configuration and running `home-manager switch` again

## Integration with Typix

Johnny-Mnemonix seamlessly integrates with Typix for document compilation. Define your Typst documents within your Johnny Decimal structure:

```nix
{
  mnemonic.documents = {
    "11.01.budget-2024" = {
      source = ./documents/budget-2024.typ;
      engine = "typst";
      dependencies = {
        fonts = [ pkgs.inter ];
        data = [ ./data/expenses.csv ];
      };
    };
  };
}
```

## Directory Navigation

Johnny-Mnemonix provides simple, fast navigation to your documents using Johnny Decimal codes. Once configured, you can quickly navigate to any location in your document hierarchy:

```bash
# Navigate directly to a specific ID location
cd ~$11.01   # Goes to $HOMEOFFICE/10-19 Personal/11 Finance/11.01 Budget/

# Or use the full path including document name
cd ~$11.01.annual-budget   # Goes to the specific document location
```

## Contributing

Contributions are welcome! See [CONTRIBUTING.md](./CONTRIBUTING.md) for guidelines.

## License

MIT License - See [LICENSE](./LICENSE) for details.
